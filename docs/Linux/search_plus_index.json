{"./":{"url":"./","title":"Introduction","keywords":"","body":"READ ME © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/0-Basic/1-Basic.html":{"url":"md/0-Basic/1-Basic.html","title":"Basic","keywords":"","body":"Basic tagsstart Linux tagsstop Introduction Linux是kernel,加上GNU社群裡面的一堆應用程式,就成了現在的OS發行版本 Windows大多直接使用administrator,是病毒氾濫的推手 root權限大到可以自殺 Tool 永中Office VLC GIMP(Photoshop) 主要分支 RedHat Red Hat Enterprise Linux(RHEL) Slackware SUSE Linux Enterprise(SUSE) Debian Ubuntu 建議用CentOS,因為KVM開發與測試環境都是在RHEL進行,而CentOS是RHEL open source的衍生(RHEL要收費,免費版無法升級或技術支援) 圖形介面 X是一種協定 xorg則是實現X協定,提供圖形化使用者介面服務的server軟體 系統開機之後自動執行xorg 1992~2004只有XFree86(GPL),後來公司改授權條款,造成GNU社群不滿,於是衍生出了xorg. X client軟體有兩個,一個叫Window Manager(WM),一個叫Display Manager(DM) 透過startx啟動xorg與default WM GNOME: Metacity KDE: K Win DM是負責圖形介面的使用者登入,開機第一個執行,且無人能關掉它 XDM KDM GDM Mac OS Ｘ協議與Linux X不同,前者是binary,後者是純文字 There is more than one way to define \"memory leak\". In particular, there are two primary definitions of \"memory leak\" that are in common usage among programmers. The first commonly used definition of \"memory leak\" is, \"Memory was allocated and was not subsequently freed before the program terminated.\" However, many programmers (rightly) argue that certain types of memory leaks that fit this definition don't actually pose any sort of problem, and therefore should not be considered true \"memory leaks\". An arguably stricter (and more useful) definition of \"memory leak\" is, \"Memory was allocated and cannot be subsequently freed because the program no longer has any pointers to the allocated memory block.\" In other words, you cannot free memory that you no longer have any pointers to. Such memory is therefore a \"memory leak\". Valgrind uses this stricter definition of the term \"memory leak\". This is the type of leak which can potentially cause significant heap depletion, especially for long lived processes. The \"still reachable\" category within Valgrind's leak report refers to allocations that fit only the first definition of \"memory leak\". These blocks were not freed, but they could have been freed (if the programmer had wanted to) because the program still was keeping track of pointers to those memory blocks. In general, there is no need to worry about \"still reachable\" blocks. They don't pose the sort of problem that true memory leaks can cause. For instance, there is normally no potential for heap exhaustion from \"still reachable\" blocks. This is because these blocks are usually one-time allocations, references to which are kept throughout the duration of the process's lifetime. While you could go through and ensure that your program frees all allocated memory, there is usually no practical benefit from doing so since the operating system will reclaim all of the process's memory after the process terminates, anyway. Contrast this with true memory leaks which, if left unfixed, could cause a process to run out of memory if left running long enough, or will simply cause a process to consume far more memory than is necessary. Probably the only time it is useful to ensure that all allocations have matching \"frees\" is if your leak detection tools cannot tell which blocks are \"still reachable\" (but Valgrind can do this) or if your operating system doesn't reclaim all of a terminating process's memory (all platforms which Valgrind has been ported to do this). © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/0-Basic/2-Shell.html":{"url":"md/0-Basic/2-Shell.html","title":"Shell","keywords":"","body":"Shell tagsstart Linux Shell tagsstop Command readelf -d -t iothub_client_sample_http find ~~~ | xargs rm diff $(readlink $(which sh)) xxd readlink -f /proc/20361/fd/1 tee lsof md5sum stty -a ctrl+w = alt+back ctrl+ cp --parent echo \"${PWD##*/}\" = basename ${PWD} tr -d '\\n' ldd nm This happens to me a lot, too, and this thread is one of the top results when googling for \"restart cinnamon\". Unfortunately, the instructions don't work for me (only because the display number is wrong!). For future visitors, here's what I do that always helps me. How do I restart Cinnamon from the tty? Cinnamon freezes Switch tty. I usually go to tty6, Ctrl+Alt+F6 If you need to login first, do so. Type w (yes, just the letter) and press enter. This commands does a lot of different things, but you need it to figure out the number of the display you are using. The display number is in the column FROM. Mine is :0 (yes, including the colon). Assuming that cinnamon is already dead (which you would notice by the windows lacking titles and that you can't move different windows around, and perhaps even not being able to use the keyboard), you type export DISPLAY=:0; cinnamon &, and don't forget the colon. I add the ampersand (&) only not to keep that tty busy. This always works for me, and I don't lose open windows. Also, I keep these instructions in a file called restartcinnamon, which is just a text file. I keep the file in my Dropbox folder, so no matter what machine I am on I can just type cat ~/Dropbox/restartcinnamon if I need to be reminded of how to do it. sed -i '/speech_language/s/value=\\\".*\\\"/value=\"zh-TW\"/' alextext.launch 查看进程pid (1) ps ux | grep prog_name (2) pgrep prog_name 查看线程tid (1) ps -efL | grep prog_name (2) ls /proc/pid/task 系統如何判斷 32bits / 64bits 在嘿嘿星期四的討論學到, Mat: 用 file /bin/bash, 結果非常淺顯易懂. sudo service network-manager restart © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/0-Basic/3-Makefile.html":{"url":"md/0-Basic/3-Makefile.html","title":"Makefile","keywords":"","body":"Makefile tagsstart Linux Makefile tagsstop 前言 $? $@ $ -Wall : 顯示所有的警告訊息 ZMQOPTS='-lzmq -lczmq' LDADD is used by NetBSD in the bsd.prog.mk Makefile, which is used to build programs of the base distribution and some of the programs in pkgsrc. LDLIBS is used by NetBSD in the sys.mk Makefile, which is used for implicit rules. LDLIBS is also used by GNU Make. LIBS is used by the GNU ./configure scripts. © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/0-Basic/4-Markdown.html":{"url":"md/0-Basic/4-Markdown.html","title":"Markdown","keywords":"","body":"Markdown tagsstart Markdown tagsstop 特殊 刪除線 至中 我是微软雅黑 color=gray 背景色是：orange 值班人员 星期一 星期二 星期三 李强 张明 王平 註腳1 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/0-Basic/5-GDB.html":{"url":"md/0-Basic/5-GDB.html","title":"GDB","keywords":"","body":"GDB tagsstart Linux GDB tagsstop All-Stop Mode In all-stop mode, whenever your program stops under gdb for any reason, all threads of execution stop, not just the current thread. This allows you to examine the overall state of the program, including switching between threads, without worrying that things may change underfoot. Conversely, whenever you restart the program, all threads start executing. This is true even when single-stepping with commands like step or next. In particular, gdb cannot single-step all threads in lockstep. Since thread scheduling is up to your debugging target's operating system (not controlled by gdb), other threads may execute more than one statement while the current thread completes a single step. Moreover, in general other threads stop in the middle of a statement, rather than at a clean statement boundary, when the program stops. You might even find your program stopped in another thread after continuing or even single-stepping. This happens whenever some other thread runs into a breakpoint, a signal, or an exception before the first thread completes whatever you requested. Whenever gdb stops your program, due to a breakpoint or a signal, it automatically selects the thread where that breakpoint or signal happened. gdb alerts you to the context switch with a message such as ‘[Switching to Thread n]’ to identify the thread. On some OSes, you can modify gdb's default behavior by locking the OS scheduler to allow only a single thread to run. set scheduler-locking mode Set the scheduler locking mode. It applies to normal execution, record mode, and replay mode. If it is off, then there is no locking and any thread may run at any time. If on, then only the current thread may run when the inferior is resumed. The step mode optimizes for single-stepping; it prevents other threads from preempting the current thread while you are stepping, so that the focus of debugging does not change unexpectedly. Other threads never get a chance to run when you step, and they are completely free to run when you use commands like ‘continue’, ‘until’, or ‘finish’. However, unless another thread hits a breakpoint during its timeslice, gdb does not change the current thread away from the thread that you are debugging. The replay mode behaves like off in record mode and like on in replay mode. show scheduler-locking Display the current scheduler locking mode. By default, when you issue one of the execution commands such as continue, next or step, gdb allows only threads of the current inferior to run. For example, if gdb is attached to two inferiors, each with two threads, the continue command resumes only the two threads of the current inferior. This is useful, for example, when you debug a program that forks and you want to hold the parent stopped (so that, for instance, it doesn't run to exit), while you debug the child. In other situations, you may not be interested in inspecting the current state of any of the processes gdb is attached to, and you may want to resume them all until some breakpoint is hit. In the latter case, you can instruct gdb to allow all threads of all the inferiors to run with the set schedule-multiple command. set schedule-multiple Set the mode for allowing threads of multiple processes to be resumed when an execution command is issued. When on, all threads of all processes are allowed to run. When off, only the threads of the current process are resumed. The default is off. The scheduler-locking mode takes precedence when set to on, or while you are stepping and set to step. show schedule-multiple Display the current mode for resuming the execution of threads of multiple processes. © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/1-Namespace/1-簡介.html":{"url":"md/1-Namespace/1-簡介.html","title":"簡介","keywords":"","body":"簡介 tagsstart Namespace tagsstop 什麼是Namespace？ 命名空間就是在大箱子(Kerne)裏面再裝一堆小箱子(Kernel Namespace) 為什麼要這麼做？ 因為如果我們想在箱子裏面放兩個外觀一模一樣的蘋果(Process)，到時候一定會無法區分 不如就放在A箱子裡面的蘋果，叫作A蘋果；放在B箱子裡面的蘋果，叫作B蘋果 命名空間有幾種？ Linux 2.6.24版的Kernel開始,提供了6種不同類型的Namespace 分別是： 程序間通信(IPC)命名空間 程序命名空間 網絡命名空間 掛載命名空間 UTS命名空間 用戶命名空間 所以有人說Namespaces是一種資源隔離方案，使得PID、Network、IPC等系統資源，不再屬於全域設定，而是某個特定的Namespace的資源 還有其他好處嘛？ 通過Namespace技術使得用戶創建的程序能夠與系統分離得更加徹底，從而不需要使用更多的底層(硬體支援)虛擬化技術 因為Namespaces是用純軟體劃分出來的概念 Namespace之間有關聯嘛？ Namespace之間的資源互相隔離、不可見的 因此在作業系統的層面上看，就會出現多個相同pid的Process User要怎麼看待Namespace 在用戶層面上只能看到屬於用戶自己Namespace下的資源 例如使用ps命令只能列出自己Namespace下的程序 使用者角度來看,每個Namespace看上去就像一個單獨的Linux系統 Image 1 - Linux的命名空間技術架構 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/1-Namespace/2-什麼是Network Namespace.html":{"url":"md/1-Namespace/2-什麼是Network Namespace.html","title":"什麼是Network Namespace","keywords":"","body":"什麼是Network Namespace tagsstart Namespace Network namespace tagsstop 什麼是Network namespace 虛擬化網路相關的功能 Linux近幾年特有的技術(Darwin/Windows無類似功能)(約Kernel 3.0開始才有) 是輕量級虛擬化技術的基礎（Docker,LXC,OpenVZ的原理） 多用在虛擬化和隔離 很少被單獨使用 虛擬化網路相關的功能,是指哪些？ 不同Network namespace內的Process,具有不同的Network資源如下： 虛擬網卡列表 IPv4和IPv6協議 Routing Table 防火牆設定 /proc/net目錄 /sys/class/net目錄 埠（socket） 有什麼特性？ 簡單說就是幾個Process之間搞小團體，小團體有私有網路資源，且小團體之間互不干擾 多用在虛擬化和隔離 如果Network Namespace之間要互相溝通怎麼辦? 在不同的Network namespace間創建通道：veth pair（虛擬網路設備對接口） 不同Network Namespace因為veth pair得以共享同一個實體網路設備 傳統沒有Network natags: Namespace,Network namespacemespace前是怎樣？ 一般乙太網路應用程式 Image 1 - 一般乙太網路應用程式 如果是ADSL/光世代的PPPoE Image 2 - PPPoE 如果是VPN Image 3 - VPN 網卡拿來當Hub用的Bridge Image 4 - Bridge Bridge相關指令: 需要安裝bridge-utils才能使用brctl brctl show - 顯示bridge狀況 brctl addbr/delbr - 新增/刪除bridge brctl addif - 將interface新增至bridge brctl delif - 將interface從bridge移除 有Network namespace後是怎樣？ 只有一個Network namespace的話 Image 5 - 一個Network namespace 複數Network namespace的話 Image 6 - 複數Network namespace 透過veth可以連接兩個Network namespace Image 7 - veth 搭配Bridge使其他Network namespace上網 Image 8 - Bridge+Network namespace 有什麼應用場景？ 多個Network namespace可以共享eth0和lo等實體網路設備 多個Apache伺服器Process可以在不同Network namespace的80埠上進行監聽 一個Process不能嗅探其他Network namespace的流量 一個Process不能關閉其他Network namespace的接口 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/1-Namespace/3-範例.html":{"url":"md/1-Namespace/3-範例.html","title":"範例","keywords":"","body":"範例 tagsstart Namespace Network namespace tagsstop 此範例的目標是？ 使用ip創建H1和H2兩個Network namespace H1擁有自己的Network namespace以及私有網路網路接口h1-eth0 H2擁有自己的Network namespace以及私有網路網路接口h2-eth0 使用ovs-vsctl創建Software Switch S1 S1有兩個埠s1-eth0和s1-eth1 S1運行在root namespace,並使用實體接口eth0，等待Controller的指令 使用veth pair與對應的Host接口相連，這樣H1和H2就可以透過S1溝通 s1-eth0和s1-eth1間的通訊資料透過Software Switch轉發 Image 1 - Example1 什麼是ip command? ip這個command是iproute2軟體包裡面的一個強大的網路配置工具 它能夠替代一些傳統的網路管理工具，例如:ifconfig、route 使用權限要為root 幾乎所有的Linux發行版本都支持該command 介紹ip command吧 ip netns add - 新增NetNS ip netns list - 列出現有的NetNS ip netns identify - 顯示PID所在的NetNS ip netns identify $$ - 顯示目前的NetNS ip netns exec - 在Network namespace執行command ip link add type veth peer name - 建立一個veth裝置 ip link set nets - 將veth搬到NetNS Step 1 - Create host namespaces 建立H1 namespaces sudo ip netns add h1 建立H2 namespaces sudo ip netns add h2 察看建立結果 sudo ip netns Image 2 - Step 1-Result Image 3 - Step 1-Topo Step 2 - Create switch 建立Switch sudo ovs-vsctl add-br s1 Image 4 - Step 2-Topo Step 3 - Create links 建立Link 1(h1-eth0 - s1-eth1) sudo ip link add h1-eth0 type veth peer name s1-eth1 建立Link 2(h2-eth0 - s1-eth2) sudo ip link add h2-eth0 type veth peer name s1-eth2 顯示連結結果 sudo ip link show Image 5 - Step 3-Result Step 4 - Move host ports into namespaces 將H1 port移到H1 namespaces sudo ip link set h1-eth0 netns h1 將H2 port接到H2 namespaces sudo ip link set h2-eth0 netns h2 顯示H1 namespaces的連結 sudo ip netns exec h1 ip link show 顯示H2 namespaces的連結 sudo ip netns exec h2 ip link show Image 6 - Step 4-Result Image 7 - Step 4-Topo Step 5 - Connect switch ports to OVS 將S1 port1連接到Switch sudo ovs-vsctl add-port s1 s1-eth1 將S1 port2連接到Switch sudo ovs-vsctl add-port s1 s1-eth2 顯示Switch的連結 sudo ovs-vsctl show Image 8 - Step 5-Topo Step 6 - Set up OpenFlow controller 設定Controller sudo ovs-vsctl set-controller s1 tcp:127.0.0.1 設定Controller監聽端口OpenFlow TCP（默認值:6633) sudo ovs-controller ptcp: 查詢OpenFlow Controller是否正確連接到S1 sudo ovs-vsctl show Image 9 - Step 6-Result Step 7 - Configure network 修改H1 port網路介面，給予H1 eth0一個 10.0.0.1 的參數 sudo ip netns exec h1 ifconfig h1-eth0 10.1 啟動H1 eth0網路介面 sudo ip netns exec h1 ifconfig lo up 修改H2 port網路介面，給予H2 eth0一個 10.0.0.2 的參數 sudo ip netns exec h2 ifconfig h2-eth0 10.2 啟動H2 eth0網路介面 sudo ip netns exec h2 ifconfig lo up 啟動Switch網路介面 sudo ifconfig s1-eth1 up sudo ifconfig s1-eth2 up Step 8 - Test network 透過H1網路介面Ping H2網路介面 sudo ip netns exec h1 ping -c1 10.2 Image 10 - Step 8-Result Image 11 - Final-Result © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/2-Mininet/1-什麼是 mininet.html":{"url":"md/2-Mininet/1-什麼是 mininet.html","title":"什麼是 mininet","keywords":"","body":"什麼是 mininet tagsstart mininet tagsstop 什麼是 mininet mininet是一個用python寫的一個Process 這個Process是一個網路模擬器(network emulator) 或者更精確的說：網路拓樸模擬器(network emulation orchestration system) 既然叫拓樸模擬器，代表它模擬了一整個:終端主機(end-hosts),路由器(router),交換器(switches)的集成系統 模擬網路系統可以做什麼？ 通常透過mininet模擬的架構,會與實際透過硬體架設的結果一致，因此可做為實體配線前的臨摹 mininet模擬的host行為跟真的一樣：你可以SSH(Secure Shell)進去並運行任意程式，也可以運行server 你也可以送出封包，就像透過真的乙太網路出去，有link speed & delay，可以觀察封包來往的狀況 可以輕易的製作支援SDN的區域網路 (後面會介紹什麼是SDN)，事實上，mininet是很適合作為一個輕量級的SDN仿真工具 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/2-Mininet/2-什麼是 SDN.html":{"url":"md/2-Mininet/2-什麼是 SDN.html","title":"什麼是 SDN","keywords":"","body":"什麼是 SDN tagsstart mininet SDN tagsstop 什麼是 SDN？ 全名是：軟體定義式網路（Software defined Networking，SDN） 要了解SDN之前，要先了解現今網路架構中，路由器除了硬體上俱備有轉送資料的能力外， 對於資料的移動控制，都是在每一台路由器中， 實作著遵守各種傳輸協定的控制軟體 例如連結層有擴展樹協定（Spanning Tree Protocol，STP）來防止封包卡在迴圈 雖然協定是共通的，但網通廠商各有各的OS與實作技術，導致一旦企業購買某一廠牌的設備， 未來更新設備時就必須遷就於該廠牌的網管功能，造成被網通廠商挾持的情形 現今這樣不是沒什麼問題嘛？ 隨著隨著雲端應用及巨量資料增加，路由表越來越龐大，判斷轉送的過程愈來愈複雜 而這些判斷需要路徑上的每一台交換器或是路由器不斷的拆分及重組封包 可想而知，結果導致傳輸效率不佳，無法有效發揮網路頻寬 網路管理人員需要客製調整各種網路設定時，也必須針對每臺交換器或路由器，逐一登入command-line設定，相當麻煩 而且透過人工逐一設定的方式也有很高的風險，一旦網路管理人員輸入了錯誤的指令，很容易造成網路服務癱瘓 於是關於控制封包這件事情，我們需要重新思考：真的需要每一台路由器拆開封包才能判斷嘛？ 所以SDN做了什麼？ 它的概念是：將網路分為控制層（Control Plane）與資料層（Data Plane） 將網路的管理權限交由控制層的控制器（Controller）軟體負責，採用集中控管的方式，同時也負責決定傳輸路徑 Image 1 - SDN SDN帶來的好處？ 讓網路的管理變得更集中 自動處理與動態因應變化 讓網路的設計、部署、管理、規模延展更為容易 可以減少IT服務日常維運，減少人為出錯 既然傳輸路徑已預先設定完成，交換器不需要透過不斷學習來尋找封包傳送的路徑，可大幅提升傳輸效率，降低延遲（Latency）的時間 可節省支出 所以網通廠怎麼看SDN？ SDN使得交換器的重要性將會不如以往 (功能會越來越單純，未來可能僅負責封包的傳送) 未來客製化的軟體就可以提供各項硬體設備的功能 於硬體設備廠商來說，將會是一大衝擊 臺灣企業還不了解SDN在未來的重要性，而且開發SDN應用程式的門檻較高 Google、Facebook、Yahoo、微軟等多家指標型的大企業投入了SDN架構與OpenFlow技術的發展 我剛好像看到OpenFlow，那是什麼？ 跟SDN是什麼關係 OpenFlow是實現SDN架構最主流的核心技術，也就是網路交換器(switch)和控制器(controller)之間的傳輸協定 就像是人類的神經一樣，負責大腦與四肢的溝通 OpenFlow技術將封包傳送的路徑看成是一條「Flow」，就好像是專屬的傳輸路徑 例如經過哪些交換器，需要多少的網路頻寬，再將傳輸路徑設定成OpenFlow路由表（Flow Table） 控制層和資料層之間，利用SSL加密，建立起安全的傳輸通道 但它只是整體SDN架構的一部分，而且也並非唯一可用的協定 OpenFlow是SDN的一部分，但SDN不是只有OpenFlow Image 2 - OpenFlow © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/2-Mininet/3-mininet 實戰.html":{"url":"md/2-Mininet/3-mininet 實戰.html","title":"mininet 實戰","keywords":"","body":"mininet 實戰 tagsstart mininet tagsstop 安裝 Debian Package sudo apt-get install mininet Build source and install git clone git://github.com/mininet/mininet mininet/util/install.sh -a 啟動 在沒有任何參數下，產生的虛擬環境為兩個host (h1,h2)，一個switch (s1)，並將h1,h2連接s1 Image 1 - Topology 啟動sudo mn Image 2 - mn mininet是基於OVS的應用軟體，當沒有設定OVS Controller時，他會退回OVS Bridge模式(不依賴Controller，預設所有node都是可以連通的) OVS:全名Open vSwitch，類似VM，主要是虛擬switch，支援OpenFlow 測試 顯示所有節點nodes Image 3 - nodes 顯示所有節點的連接關係net Image 4 - net 察看所有節點的資訊:dump Image 5 - dump 用h1 ping h2 一個封包h1 ping -c 1 h2 Image 6 - ping 叫出兩個host的命令視窗xterm h1 h2 Image 7 - xterm Mininet Python API Topo: Mininet拓撲結構的base class build(): The method to override in your topology class. Constructor parameters (n) will be passed through to it automatically by Topo.init(). addSwitch(): 給拓撲結構中增加一個switch，返回switch名字 addHost(): 增加host，返回host名字 addLink(): 增加一個雙向link，返回link的key Mininet: 建立和管理網路的main class start(): 開啟網路 pingAll(): 通過host之間的互ping測試連通性 stop(): 關閉網絡 net.hosts: 網路中的所有主機 dumpNodeConnections(): 所有的連接關係 setLogLevel( 'info' | 'debug' | 'output' ): set Mininet's default output level; 'info' is recommended as it provides useful information. 寫一個Python範例 目標 啟動50個hosts，作為VM server farm 啟動1個controller 啟動1個switch Image 8 - Server Farm Code example #!/usr/bin/python import re from mininet.net import Mininet from mininet.node import Controller from mininet.cli import CLI from mininet.link import Intf from mininet.log import setLogLevel, info, error from mininet.util import quietRun from mininet.node import OVSController def checkIntf( intf ): \"Make sure intf exists and is not configured.\" if ( ' %s:' % intf ) not in quietRun( 'ip link show' ): error( 'Error:', intf, 'does not exist!\\n' ) exit( 1 ) ips = re.findall( r'\\d+\\.\\d+\\.\\d+\\.\\d+', quietRun( 'ifconfig ' + intf ) ) if ips: error( 'Error:', intf, 'has an IP address and is probably in use!\\n' ) exit( 1 ) def myNetwork(): net = Mininet( topo=None, build=False) info( '*** Adding controller\\n' ) net.addController(name='c0',controller = OVSController) info( '*** Add switches\\n') s1 = net.addSwitch('s1') max_hosts = 50 newIntf = 'enp3s0' host_list = {} info( '*** Add hosts\\n') for i in xrange(1,max_hosts+1): host_list[i] = net.addHost('h'+str(i)) info( '*** Add links between ',host_list[i],' and s1 \\r') net.addLink(host_list[i], s1) info( '*** Checking the interface ', newIntf, '\\n' ) checkIntf( newIntf ) switch = net.switches[ 0 ] info( '*** Adding', newIntf, 'to switch', switch.name, '\\n' ) brintf = Intf( newIntf, node=switch ) info( '*** Starting network\\n') net.start() CLI(net) net.stop() if __name__ == '__main__': setLogLevel( 'info' ) myNetwork() 執行 sudo python example.py Image 9 - example Q&A 執行出現Cannot find required executable ovs-controller 你沒有安裝ovs-controller sudo apt-get install openvswitch-testcontroller ovs-controller是舊名稱，所以你需要複製一下 sudo cp /usr/bin/ovs-testcontroller /usr/bin/ovs-controller 執行出現 Exception: Please shut down the controller which is running on port 6653: Active Internet connections (servers and established) tcp 0 0 0.0.0.0:6653 0.0.0.0:* LISTEN 30215/ovs-testcontr 你需要kill正在背景執行的ovs-testcontroller sudo netstat -lptu sudo service ovs-testcontroller stop Mininet建立網路的三種方式 底層API Node & Link h1 = Host( 'h1' ) h2 = Host( 'h2' ) s1 = OVSSwitch( 's1', inNamespace=False ) c0 = Controller( 'c0', inNamespace=False ) Link( h1, s1 ) Link( h2, s1 ) h1.setIP( '10.1/8' ) h2.setIP( '10.2/8' ) c0.start() s1.start( [ c0 ] ) print h1.cmd( 'ping -c1', h2.IP() ) s1.stop() c0.stop() 中層API net Object net = Mininet() h1 = net.addHost( 'h1' ) h2 = net.addHost( 'h2' ) s1 = net.addSwitch( 's1' ) c0 = net.addController( 'c0' ) net.addLink( h1, s1 ) net.addLink( h2, s1 ) net.start() print h1.cmd( 'ping -c1', h2.IP() ) CLI( net ) net.stop() 上層API Topology Object class SingleSwitchTopo( Topo ): \"Single Switch Topology\" def __init__( self, count=1, **params ): Topo.__init__( self, **params ) hosts = [ self.addHost( 'h%d' % i ) for i in range( 1, count + 1 ) ] s1 = self.addSwitch( 's1' ) for h in hosts: self.addLink( h, s1 ) net = Mininet( topo=SingleSwitchTopo( 3 ) ) net.start() CLI( net ) net.stop() © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/2-Mininet/4-運作原理/1-Network Namespace.html":{"url":"md/2-Mininet/4-運作原理/1-Network Namespace.html","title":"Network Namespace","keywords":"","body":"Network Namespace Mininet虛擬化的核心機制是？ Linux Network Namespace是Mininet軟體架構的基石，用其創建虛擬節點 需要先了解Linux Namespace 之中的 Network Namespaces 預設情況下，Mininet會為每一個host創建一個新的Network Namespaces 由於每個host都有各自獨立的Network Namespaces，我們就可以進行個性化的網路配置和程式佈署 Switch和Controller運行在root Namespace，因此兩個Processes共享同一個Network Namespaces 由於Linux Namespace的虛擬技術沒有提供類似於VM的持久化能力，所以在Mininet關閉時不能保存所有設定 Mininet建立的Network namespace是nameless的，所以透過ip netns list是查看不到的 而透過ip netns add建立的Network Namespace是帶name的，這是兩者最明顯的區別之處Discussions Linux Network Namespace在OpenStack和Docker等開源項目中也廣泛應用主要用於作業系統層級的虛擬化，包含虛擬網路 解釋一下，上一個的範例與namespace的關聯 範例中Host H1和Host H2連接到運行在Kernel的root namespace的Switch S1 H1和H2擁有自己的網路匿名命名空間以及私有網路接口h1-eth0和h2-eth0 S1有兩個埠s1-eth1和s1-eth2，通過veth pair與Host接口相連，這樣H1和H2就可以透過S1進行交流 s1-eth0和s1-eth1間的data轉發透過S1完成，並使用實體接口eth0，等待Controller的指令 Image 1 - Example1 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/2-Mininet/4-運作原理/2-Node.html":{"url":"md/2-Mininet/4-運作原理/2-Node.html","title":"Node","keywords":"","body":"Node Node是什麼？ 每個Host其實就是一個Node的物件，可以在node.py中看到此物件的定義 node.py class Node( object ): portBase = 0 # Nodes always start with eth0/port0, even in OF 1.0 def __init__( self, name, inNamespace=True, **params ): self.checkSetup() self.name = params.get( 'name', name ) self.privateDirs = params.get( 'privateDirs', [] ) self.inNamespace = params.get( 'inNamespace', inNamespace ) ... # Start command interpreter shell self.startShell() self.mountPrivateDirs() inToNode = {} # mapping of input fds to nodes outToNode = {} # mapping of output fds to nodes 初始時，會有一個變數inNamespace用來決定此Host是否要透過network namespaces來達到network isolation的功能 當變數都初始化後，就會呼叫startShell()來啟動此Host node.py def startShell( self, mnopts=None ): \"Start a shell process for running commands\" if self.shell: error( \"%s: shell is already running\\n\" % self.name ) return # mnexec: (c)lose descriptors, (d)etach from tty, # (p)rint pid, and run in (n)amespace opts = '-cd' if mnopts is None else mnopts if self.inNamespace: opts += 'n' # bash -i: force interactive # -s: pass $* to shell, and make process easy to find in ps # prompt is set to sentinel chr( 127 ) cmd = [ 'mnexec', opts, 'env', 'PS1=' + chr( 127 ), 'bash', '--norc', '-is', 'mininet:' + self.name ] master, slave = pty.openpty() self.shell = self._popen( cmd, stdin=slave, stdout=slave,stderr=slave,close_fds=False ) ... 可以觀察到，mininet是透過一隻叫做mnexec的程式來執行，並且透過參數-n來將此process給轉換到network namespaces中 所以建立完Host以後，可以使用ip來看？ 理論上我們要可以透過ip netns show來看到這些network namespaces，實際上卻看不到 原因如同此篇所說，由於建立的為nameless network namespaces Host是Node，那Switch呢？ 建立Switch包含了四種選擇OVSLegacyKernelSwitch、UserSwitch、OVSSwitch，IVSSwitch 一般常用的就是OVSSwitch 這四種Switch都繼承自Switch物件，而Switch物件則繼承自Node © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/2-Mininet/4-運作原理/3-Link.html":{"url":"md/2-Mininet/4-運作原理/3-Link.html","title":"Link","keywords":"","body":"Link 接下來會根據拓墣的Link情況，去創建對應的Interface 首先，這邊使用到Link這個物件來表示每一條Link 每個Link實際上對應到的是兩個Node上面的Interface link.py class Link( object ): \"\"\"A basic link is just a veth pair. Other types of links could be tunnels, link emulators, etc..\"\"\" # pylint: disable=too-many-branches def __init__( self, node1, node2, port1=None, port2=None, intfName1=None, intfName2=None, addr1=None, addr2=None, intf=Intf, cls1=None, cls2=None, params1=None, params2=None, fast=True ): \"\"\"Create veth link to another node, making two new interfaces. node1: first node node2: second node port1: node1 port number (optional) port2: node2 port number (optional) intf: default interface class/constructor cls1, cls2: optional interface-specific constructors intfName1: node1 interface name (optional) intfName2: node2 interface name (optional) params1: parameters for interface 1 params2: parameters for interface 2\"\"\" # This is a bit awkward; it seems that having everything in # params is more orthogonal, but being able to specify # in-line arguments is more convenient! So we support both. if params1 is None: params1 = {} if params2 is None: params2 = {} # Allow passing in params1=params2 if params2 is params1: params2 = dict( params1 ) if port1 is not None: params1[ 'port' ] = port1 if port2 is not None: params2[ 'port' ] = port2 if 'port' not in params1: params1[ 'port' ] = node1.newPort() if 'port' not in params2: params2[ 'port' ] = node2.newPort() if not intfName1: intfName1 = self.intfName( node1, params1[ 'port' ] ) if not intfName2: intfName2 = self.intfName( node2, params2[ 'port' ] ) self.fast = fast if fast: params1.setdefault( 'moveIntfFn', self._ignore ) params2.setdefault( 'moveIntfFn', self._ignore ) self.makeIntfPair( intfName1, intfName2, addr1, addr2, node1, node2, deleteIntfs=False ) 這邊要觀察到的，Link物件會呼叫makeIntfPair此方法，此方法就可以將兩個Interface給串接起來 util.py def makeIntfPair( intf1, intf2, addr1=None, addr2=None, node1=None, node2=None, deleteIntfs=True, runCmd=None ): \"\"\"Make a veth pair connnecting new interfaces intf1 and intf2 intf1: name for interface 1 intf2: name for interface 2 addr1: MAC address for interface 1 (optional) addr2: MAC address for interface 2 (optional) node1: home node for interface 1 (optional) node2: home node for interface 2 (optional) deleteIntfs: delete intfs before creating them runCmd: function to run shell commands (quietRun) raises Exception on failure\"\"\" if not runCmd: runCmd = quietRun if not node1 else node1.cmd runCmd2 = quietRun if not node2 else node2.cmd if deleteIntfs: # Delete any old interfaces with the same names runCmd( 'ip link del ' + intf1 ) runCmd2( 'ip link del ' + intf2 ) # Create new pair netns = 1 if not node2 else node2.pid if addr1 is None and addr2 is None: cmdOutput = runCmd( 'ip link add name %s ' 'type veth peer name %s ' 'netns %s' % ( intf1, intf2, netns ) ) else: cmdOutput = runCmd( 'ip link add name %s ' 'address %s ' 'type veth peer name %s ' 'address %s ' 'netns %s' % ( intf1, addr1, intf2, addr2, netns ) ) if cmdOutput: raise Exception( \"Error creating interface pair (%s,%s): %s \" % ( intf1, intf2, cmdOutput ) ) 這邊可以看到，mininet實際上是透過系統中的ip link的方法，將兩個interface創造一條veth的Link 此時，我們的系統如下 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/2-Mininet/4-運作原理/4-Interface.html":{"url":"md/2-Mininet/4-運作原理/4-Interface.html","title":"Interface","keywords":"","body":"Interface 接下來我們要把這些interface給綁到特定的Node身上 在Link物件初始化後段，會去初始化兩個Interface真正的物件本體 link.py class Intf( object ): \"Basic interface object that can configure itself.\" def __init__( self, name, node=None, port=None, link=None, mac=None, **params ): \"\"\"name: interface name (e.g. h1-eth0) node: owning node (where this intf most likely lives) link: parent link if we're part of a link other arguments are passed to config()\"\"\" self.node = node self.name = name self.link = link self.mac = mac self.ip, self.prefixLen = None, None # if interface is lo, we know the ip is 127.0.0.1. # This saves an ifconfig command per node if self.name == 'lo': self.ip = '127.0.0.1' # Add to node (and move ourselves if necessary ) moveIntfFn = params.pop( 'moveIntfFn', None ) if moveIntfFn: node.addIntf( self, port=port, moveIntfFn=moveIntfFn ) else: node.addIntf( self, port=port ) # Save params for future reference self.params = params self.config( **params ) 這邊要觀察的重點是每個Interface都會去呼叫node.addIntf( self, port=port )來處理 node.py def addIntf( self, intf, port=None, moveIntfFn=moveIntf ): \"\"\"Add an interface. intf: interface port: port number (optional, typically OpenFlow port number) moveIntfFn: function to move interface (optional)\"\"\" if port is None: port = self.newPort() self.intfs[ port ] = intf self.ports[ intf ] = port self.nameToIntf[ intf.name ] = intf debug( '\\n' ) debug( 'added intf %s (%d) to node %s\\n' % ( intf, port, self.name ) ) if self.inNamespace: debug( 'moving', intf, 'into namespace for', self.name, '\\n' ) moveIntfFn( intf.name, self ) 此方法最後會呼叫moveIntf來將該interface給處理，moveIntf則會呼叫moveIntfNoRetry將Interface給綁入到每個Node中 util.py def moveIntf( intf, dstNode, printError=True, retries=3, delaySecs=0.001 ): \"\"\"Move interface to node, retrying on failure. intf: string, interface dstNode: destination Node printError: if true, print error\"\"\" retry( retries, delaySecs, moveIntfNoRetry, intf, dstNode, printError=printError ) def moveIntfNoRetry( intf, dstNode, printError=False ): \"\"\"Move interface to node, without retrying. intf: string, interface dstNode: destination Node printError: if true, print error\"\"\" intf = str( intf ) cmd = 'ip link set %s netns %s' % ( intf, dstNode.pid ) cmdOutput = quietRun( cmd ) # If ip link set does not produce any output, then we can assume # that the link has been moved successfully. if cmdOutput: if printError: error( '*** Error: moveIntf: ' + intf + ' not successfully moved to ' + dstNode.name + ':\\n', cmdOutput ) return False return True 可以看到，透過指令ip link set %s netns %s，將特定的interface塞入特定Node的namespace之中 此時，我們的系統如下 Image 1 - 拓墣 最後OVSSwitch透過ovs-vsctl add-port將Switch上面的Interface都給OVS控管 node.py def attach( self, intf ): \"Connect a data port\" self.vsctl( 'add-port', self, intf ) self.cmd( 'ifconfig', intf, 'up' ) self.TCReapply( intf ) def vsctl( self, *args, **kwargs ): \"Run ovs-vsctl command (or queue for later execution)\" if self.batch: cmd = ' '.join( str( arg ).strip() for arg in args ) self.commands.append( cmd ) else: return self.cmd( 'ovs-vsctl', *args, **kwargs ) © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/3-Git/1-Basic.html":{"url":"md/3-Git/1-Basic.html","title":"Basic","keywords":"","body":"Basic tagsstart Git tagsstop Introduction git config --global user.name \"\" git config --global user.email \"\" git config --global alias.co checkout git config --global core.editor vim git init 使用 git status 來檢視所有檔案的狀態 使用 git add 來告知 git，哪些是我們即將要提交（commit）的檔案 git rm 使用 git commit 來提交一個 patch，並且使用 vim 編輯提交訊息（包含標題及內容） git mv 使用 git log 檢視提交的歷史訊息 --oneline使用 git show 檢視最後一次提交的 patch 所修改內容 git add --all 不論檔案狀態是 Untracked files 或是 Changes not staged for commit（紅色），都會一口氣變成 Changes to be committed（綠色） git add -u # 一次加入所有被更動的檔案，包含 modified 及 deleted Changes not staged for commit（紅色），都會一口氣變成 Changes to be committed（綠色） git add -f 強制 add 被忽略的檔案 第一行為 commit message 的標題（僅限一行） 第二行保留空白 第三行以後是 commit message 的內容（可略過不寫） git diff 只能檢視 Changes not staged for commit 區塊（紅色）的修改內容 git diff hello_world.txt git diff --cached # 檢視Changes to be committed(綠色)部分的內容 git reset git reset HEAD 使用 git reset HEAD 來還原 \"檔案狀態\" 使用 git checkout -- 來還原 \"檔案內容\" 使用 git reset --soft HEAD^ 使 patch 回到上一個階段的 Changes to be committed git reset --soft HEAD@{1} git reset --hard HEAD 可以一次將 Changes not staged for commit 和 Changes to be committed 的區域清空，但不包含Untracked files git reset HEAD^ 回到前一個 patch，且恢復檔案的狀態 git reset --soft HEAD^ 回到前一個 patch，但保持檔案狀態為 Changes to be committed git reset --hard HEAD^ 回到前一個 patch，且強制清除檔案的修改內容 忽略Untracked files .gitignore *.exe # 忽略所有 xxx.exe 的檔案 接著我們可以透過 git checkout -- 來還原檔案的內容 $ git checkout -- num.txt 組合記 $git add -A # 把所有檔案加到 Changes to be committed $git reset --hard HEAD # 一次還原所有檔案的內容 組合記的組合記 $git submodule foreach --recursive git add -A $git submodule foreach --recursive git reset --hard HEAD HEAD^ 或 HEAD~1 可以用來表示上一個 patch HEAD^^ 或 HEAD~2 可以用來表示上兩個 patch HEAD^^^ 或 HEAD~3 可以用來表示上三個 patch git show HEAD~2 在 git 的世界裡，凡事 HEAD 發生改變都會被記錄下來 哪些時候 HEAD 會發生改變呢？ git commit 提交一份新的 patch，HEAD 會轉移到新的 patch git reset --hard 切換 patch 的時候 git cherry-pick/revert ... 挑入/挑出 patch 的時候 git checkout 切換分支的時候 git merge/rebase ... 合併分支的時候 git reflog 用來看Head的移動 git log -g 查看 reflog 的詳細內+ git commit --amend 的注意事項（非常雷 x 2） 使用指令 git commit --amend 後，會馬上進入 vim 的文字編輯模式 git 不論你是否有修改 commit message 或是用 :q! 不存檔直接離開 vim 都會為你重新產生新的 commit id 有時候這並不一定是我們想要的結果，要特別留意！ 例如說，我們從 server 上抓了最新的 code 下來，準備要新增一個功能再上傳至 server 但是你好死不死的手殘按到 git commit --amend 先改到了最新的 patch（P0） 這時候儘管你按 :q! 退出 vim，但是 commit id 早就已經被改掉了（P0'） 然後我們基於 P0' 來開發新功能，並且 commit 了一個新的 patch（P1） 這時候我們要上傳 patch 的時候，會遇到被 git server 拒絕的情形 被拒絕的原因是，server 認為你提交的 patch 跟 server 的 code 並沒有兩樣 但其實主要原因是，server 認為你上傳了兩個的 patch，分別是 P0' 跟 P1 server 先用 P0' 跟 P0 最比對，發現兩個 patch 根本就一模一樣，就直接拒絕了 當你絞盡腦汁的想要找出 P1 哪裡有問題的時候，其實是被 git commit --amend 背後默默捅了一刀 因此上傳 patch 前請確保 parent id 正確無誤 git commit --amend # 使用後會進入 vim 文字編輯模式。把標題改成 \"Add 77\" 然後存檔離開 $ git reset --hard edb3d9c # 回到 P3 $ git cherry-pick b2dbf88 # 挑入 P5 → P5' $ git cherry-pick 8cb205e # 挑入 P6 → P6' 解完衝突請執行 git cherry-pick --continue 若要放棄請執行 git cherry-pick --abort $ git rebase -i # 啟動 rebase 互動模式 如果不想要有 git reflog 的紀錄的話，就要將把 TODO 的內容清空或是註解掉 git rebase --skip git rebase --continue git rebase --abort 全部取消，並且回到 rebase 前的狀態 patch 多沒有關係，但 patch 改的內容要越細越好 git branch git branch git checkout 切換分支 git clone -b RB14.12 https://git.allseenalliance.org/gerrit/core/alljoyn.git git checkout -b $ git checkout git branch -f git branch -D 刪除分支 我們必須切到其它分支上，才能把 feature 分支刪除 git checkout 移動 HEAD 的位置 git push (遠端倉庫名ex:orginal) (分支名ex:master) Git 除了可以用 cherry-pick 和 rebase 的方式來合併分支之外 還可以用 merge 指令來合併分支 git merge bugFix git stash git stash list git config --global core.editor vim git add submoudle git submoudle add subdir git clone submoudle git clone --recurse-submodules https://github.com/schnell18/dotvim.git update submoudle git submodule foreach git pull origin Merge detached HEAD back to origin/master – Git $git checkout c2744f95d $git checkout –b temp #makes a new branch from current detached HEAD $git branch –f master temp #update master to point to the new branch $git branch –d temp #delete the branch $git push origin master #push the re-established history git pull --rebase 加上 rebase 的意思是，會先 1.把本地 repo. 從上次 pull 之後的變更暫存起來 2. 回復到上次 pull 時的情況 3. 套用遠端的變更 4. 最後再套用剛暫存下來的本地變更。詳細說明可以參考 pull with rebase。 git push origin HEAD:master If you want to stash only specific files, do the following: Stage the files you don't want to stash And the following command: git stash save --keep-index For example # On branch develop # Changes to be committed: # (use \"git reset HEAD ...\" to unstage) # # modified: fileA # modified: fileB # # Changes not staged for commit: # (use \"git add ...\" to update what will be committed) # (use \"git checkout -- ...\" to discard changes in working directory) # # modified: fileC # modified: fileD git stash save --keep-index © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/4-Gstreamer/1-Basic.html":{"url":"md/4-Gstreamer/1-Basic.html","title":"Basic","keywords":"","body":"GStreamer tagsstart GStreamer Voice Video tagsstop 前言 pipeline Bins elements source pads sink pads GstBuffer from sources to sinks ((downstream) GstEvent upstream and downstream , 可以從application to element queries messages Image 1 - 1 Image 2 - 2 Image 3 - 3 code $(CC) --silent --tag=CC --mode=link -o $@ -lrt -ldl gst_init (&argc, &argv); gst_version (&major, &minor, &micro, &nano); GST_VERSION_MAJOR GST_VERSION_MINOR GST_VERSION_MICRO GstElement *element; element = gst_element_factory_make (\"fakesrc\", \"source\"); gst_object_unref (GST_OBJECT (element)); gchar *name; g_object_get (G_OBJECT (element), \"name\", &name, NULL); g_free (name); gst_pipeline_new gst_pipeline_get_bus gst_bus_add_watch g_main_loop_new g_main_loop_run gst_pipeline_new bus/message pipeline message handler - mainloop gchar *debug; GError *error; gst_message_parse_error (msg, &error, &debug); g_free (debug); g_printerr (\"Error: %s\\n\", error->message); g_error_free (error); End-of-stream Error Tags State-changes Buffering Element messages Application-specific messages gst_bin_add_many gst_element_link gst_element_link_many g_warning bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline); gst_bus_add_signal_watch (bus); g_signal_connect (bus, \"message::error\", G_CALLBACK (cb_message_error), NULL); g_signal_connect (bus, \"message::eos\", G_CALLBACK (cb_message_eos), NULL); gst_element_get_static_pad (decoder, \"sink\"); gst_pad_link (pad, sinkpad); pad = always sometimes未知來源 ,on request聚合器 ＆Tee elements（複製） gst_element_link (source, demuxer); gst_element_link_many (decoder, conv, sink, NULL); g_signal_connect (demuxer, \"pad-added\", G_CALLBACK (on_pad_added), decoder); pad = gst_element_get_request_pad (tee, \"src%d\"); name = gst_pad_get_name (pad); gst_element_get_pad_list() 調用gst_pad_get_parent()可以獲得指定襯墊所屬的元件，該函數的返回值是一個指向GstElement的指針。 gst_element_get_compatible_pad (mux, tolink_pad); gst_pad_link (tolinkpad, pad); gst_element_set_state GST_STATE_NULL GST_STATE_READY GST_STATE_PAUSED GST_STATE_PLAYING Capabilities 目標 Autoplugging Compatibility detection Metadata Filtering ：audioconvert, audioresample, ffmpegcolorspace or videoscale const GstStructure *str; str = gst_caps_get_structure (caps, 0); if (!gst_structure_get_int (str, \"width\", &width) || !gst_structure_get_int (str, \"height\", &height)) { g_print (\"No width/height available\\n\"); return; } gst_element_link_filtered (demuxer, decoder, caps); struct _GstCaps { gchar *name; /* the name of this caps */ guint16 id; /* type id (major type) */ guint refcount; /* caps are refcounted */ GstProps *properties; /* properties for this capability */ GstCaps *next; /* caps can be chained together */ }; gst_caps_get_name (cap), gst_caps_get_mime (cap)); 在GStreamer應用程序中使用的箱櫃主要有兩種類型： GstPipeline管道是最常用到的容器，對於一個GStreamer應用程序來講，其頂層箱櫃必須是一條管道。 GstThread線程的作用在於能夠提供同步處理能力，如果GStreamer應用程序需要進行嚴格的音視頻同步，一般都需要用到這種類型的箱櫃。 GstElement *thread, *pipeline; //創建線程對象，同時為其指定唯一的名稱。 thread = gst_element_factory_make (\"thread\", NULL); //根據給出的名稱，創建一個特定的管道對象。 pipeline = gst_pipeline_new (\"pipeline_name\"); 箱櫃（bin）是GStreamer框架中的容器元件，它通常被用來容納其它的元件對象，但由於其自身也是一個GstElement對象 而要從箱櫃中找到特定的元件也很容易，可以藉助gst_bin_get_by_name()函數實現： GstElement *element; element = gst_bin_get_by_name (GST_BIN (bin), \"decoder\"); gst_bin_remove() 由於GStreamer框架中的一個箱櫃能夠添加到另一個箱櫃之中，因此有可能會出現箱櫃嵌套的情況 具有精靈襯墊的箱櫃在行為上與元件是完全相同的，所有元件具有的屬性它都具有，所有針對元件能夠進行的操作也同樣能夠針對箱櫃進行，因此在GStreamer應用程序中能夠像使用元件一樣使用這類箱櫃。下面的代碼示範瞭如何為箱櫃添加一個精靈襯墊： GstElement *bin; GstElement *element; element = gst_element_factory_create (\"mad\", \"decoder\"); bin = gst_bin_new (\"bin_name\"); gst_bin_add (GST_BIN (bin), element); gst_element_add_ghost_pad (bin, gst_element_get_pad (element, \"sink\"), \"sink\"); 示範瞭如何將兩個元件通過襯墊連接起來 //連接 gst_pad_link (srcpad, sinkpad); //斷開 gst_pad_unlink (srcpad, sinkpad); 別：初級 肖文鵬,自由軟件愛好者 2004年6月01日 GStreamer是GNOME桌面環境下用來構建流媒體應用的編程框架（framework），其目標是要簡化音/視頻應用程序的開發，目前已經能夠被用來處理像MP3、Ogg、MPEG1、MPEG2、AVI、 Quicktime等多種格式的多媒體數據。 一、基本概念 GStreamer作為GNOME桌面環境推薦的流媒體應用框架，採用了基於插件（plugin）和管道（pipeline）的體系結構，框架中的所有的功能模塊都被實現成可以插拔的組件（component），並且在需要的時候能夠很方便地安裝到任意一個管道上，由於所有插件都通過管道機制進行統一的數據交換，因此很容易利用已有的各種插件“組裝”出一個功能完善的多媒體應用程序。 1.1元件處理 對於需要應用GStreamer框架的程序員來講，GstElement是一個必須理解的概念，因為它是組成管道的基本構件，也是框架中所有可用組件的基礎，這也難怪GStreamer框架中的大部分函數都會涉及到對GstElement對象的操作。從GStreamer自身的觀點來看，GstElement可以描述為一個具有特定屬性的黑盒子，它通過連接點（link point）與外界進行交互，向框架中的其餘部分錶徵自己的特性或者功能。 按照各自功能上的差異，GStreamer又將GstElement細分成如下幾類： Source Element數據源元件只有輸出端，它僅能用來產生供管道消費的數據，而不能對數據做任何處理。一個典型的數據源元件的例子是音頻捕獲單元，它負責從聲卡讀取原始的音頻數據，然後作為數據源提供給其它模塊使用。 Filter Element過濾器元件既有輸入端又有輸出端，它從輸入端獲得相應的數據，並在經過特殊處理之後傳遞給輸出端。一個典型的過濾器元件的例子是音頻編碼單元，它首先從外界獲得音頻數據，然後根據特定的壓縮算法對其進行編碼，最後再將編碼後的結果提供給其它模塊使用。 Sink Element接收器元件只有輸入端，它僅具有消費數據的能力，是整條媒體管道的終端。一個典型的接收器元件的例子是音頻回放單元，它負責將接收到的數據寫到聲卡上，通常這也是音頻處理過程中的最後一個環節。 圖1將有助於你更好地理解數據源元件、過濾器元件和接收器元件三者的區別，同時也不難看出它們是如何相互配合形成管道的： 圖1 需要注意的是，過濾器元件的具體形式是非常靈活的，GStreamer並沒有嚴格規定輸入端和輸出端的數目，事實上它們都可以是一個或者多個。圖2是一個AVI分離器的基本結構，它能夠將輸入數據分離成單獨的音頻信息和視頻信息，用於實現該功能的過濾器元件很明顯只具有一個輸入端，但卻需要有兩個輸出端。 圖2 要想在應用程序中創建GstElement對象，唯一的辦法是藉助於工廠對象GstElementFactory。由於GStreamer框架提供了多種類型的GstElement對象，因此對應地提供了多種類型的GstElementFactory對象，它們是通過特定的工廠名稱來進行區分的。例如，下面的代碼通過gst_element_factory_find()函數獲得了一個名為mad的工廠對象，它之後可以用來創建與之對應的MP3解碼器元件： GstElementFactory *factory; factory = gst_element_factory_find (\"mad\"); 成功獲得工廠對象之後，接下來就可以通過gst_element_factory_create()函數來創建特定的GstElement對象了，該函數在調用時有兩個參數，分別是需要用到的工廠對象，以及即將創建的元件名稱。元件名稱可以用查詢的辦法獲得，也可以通過傳入空指針（NULL）來生成工廠對象的默認元件。下面的代碼示範瞭如何利用已經獲得的工廠對象，來創建名為decoder的MP3解碼器元件： GstElement *element; element = gst_element_factory_create (factory, \"decoder\"); 當創建的GstElement不再使用的時候，還必須調用gst_element_unref()函數釋放其占用的內存資源： gst_element_unref (element); GStreamer使用了與GObject相同的機制來對屬性（property）進行管理，包括查詢（query）、設置（set）和讀取（get）等。所有的GstElement對像都需要從其父對象GstObject那裡繼承名稱（name）這一最基本的屬性，這是因為像gst_element_factory_make()和gst_element_factory_create()這樣的函數在創建工廠對象和元件對象時都會用到名稱屬性，通過調用gst_object_set_name()和gst_object_get_name()函數可以設置和讀取GstElement對象的名稱屬性。 1.2襯墊處理 襯墊（pad）是GStreamer框架引入的另外一個基本概念，它指的是元件（element）與外界的連接通道，對於框架中的某個特定元件來說，其能夠處理的媒體類型正是通過襯墊暴露給其它元件的。成功創建GstElement對象之後，可以通過gst_element_get_pad()獲得該元件的指定襯墊。例如，下面的代碼將返回element元件中名為src的襯墊： GstPad *srcpad; srcpad = gst_element_get_pad (element, \"src\"); 如果需要的話也可以通過gst_element_get_pad_list()函數，來查詢指定元件中的所有襯墊。例如，下面的代碼將輸出element元件中所有襯墊的名稱： GList *pads; pads = gst_element_get_pad_list (element); while (pads) { GstPad *pad = GST_PAD (pads->data); g_print (\"pad name is: %s\\n\", gst_pad_get_name (pad)); pads = g_list_next (pads); } 與元件一樣，襯墊的名稱也能夠動態設置或者讀取，這是通過調用gst_pad_get_name ()和gst_pad_set_name()函數來完成的。所有元件的襯墊都可以細分成輸入襯墊和輸出襯墊兩種，其中輸入襯墊只能接收數據但不能產生數據，而輸出襯墊則正好相反，只能產生數據但不能接收數據，利用函數gst_pad_get_direction()可以獲得指定襯墊的類型。 GStreamer框架中的所有襯墊都必然依附於某個元件之上，調用gst_pad_get_parent()可以獲得指定襯墊所屬的元件，該函數的返回值是一個指向GstElement的指針。襯墊從某種程度上可以看成是元件的代言人，因為它要負責向外界描述該元件所具有的能力。 GStreamer框架提供了統一的機制來讓襯墊描述元件所具有的能力（capability），這是藉助數據結構_GstCaps來實現的： struct _GstCaps { gchar *name; /* the name of this caps */ guint16 id; /* type id (major type) */ guint refcount; /* caps are refcounted */ GstProps *properties; /* properties for this capability */ GstCaps *next; /* caps can be chained together */ }; 以下是對mad元件的能力描述，不難看出該元件中實際包含sink和src兩個襯墊，並且每個襯墊都帶有特定的功能信息。名為sink的襯墊是mad元件的輸入端，它能夠接受MIME類型為audio/mp3的媒體數據，此外還具有layer、bitrate和framed三種屬性。名為src的襯墊是mad元件的輸出端，它負責產生MIME類型為audio/raw媒體數據，此外還具有format、depth、rate和channels等多種屬性。 Pads: SINK template: ’sink’ Availability: Always Capabilities: ’mad_sink’: MIME type: ’audio/mp3’: SRC template: ’src’ Availability: Always Capabilities: ’mad_src’: MIME type: ’audio/raw’: format: String: int endianness: Integer: 1234 width: Integer: 16 depth: Integer: 16 channels: Integer range: 1 - 2 law: Integer: 0 signed: Boolean: TRUE rate: Integer range: 11025 - 48000 準確地說，GStreamer框架中的每個襯墊都可能對應於多個能力描述，它們能夠通過函數gst_pad_get_caps()來獲得。例如，下面的代碼將輸出pad襯墊中所有能力描述的名稱及其MIME類型： GstCaps *caps; caps = gst_pad_get_caps (pad); g_print (\"pad name is: %s\\n\", gst_pad_get_name (pad)); while (caps) { g_print (\" Capability name is %s, MIME type is %s\\n\", gst_caps_get_name (cap), gst_caps_get_mime (cap)); caps = caps->next; } 1.3箱櫃 箱櫃（bin）是GStreamer框架中的容器元件，它通常被用來容納其它的元件對象，但由於其自身也是一個GstElement對象，因此實際上也能夠被用來容納其它的箱櫃對象。利用箱櫃可以將需要處理的多個元件組合成一個邏輯元件，由於不再需要對箱櫃中的元件逐個進行操作，因此能夠很容易地利用它來構造更加複雜的管道。在GStreamer框架中使用箱櫃還有另外一個優點，那就是它會試著對數據流進行優化，這對於多媒體應用來講是很具吸引力的。 圖3描述了箱櫃在GStreamer框架中的典型結構： 圖3 在GStreamer應用程序中使用的箱櫃主要有兩種類型： GstPipeline管道是最常用到的容器，對於一個GStreamer應用程序來講，其頂層箱櫃必須是一條管道。 GstThread線程的作用在於能夠提供同步處理能力，如果GStreamer應用程序需要進行嚴格的音視頻同步，一般都需要用到這種類型的箱櫃。 GStreamer框架提供了兩種方法來創建箱櫃：一種是藉助工廠方法，另一種則是使用特定的函數。下面的代碼示範瞭如何使用工廠方法創建線程對象，以及如何使用特定函數來創建管道對象： GstElement *thread, *pipeline; //創建線程對象，同時為其指定唯一的名稱。 thread = gst_element_factory_make (\"thread\", NULL); //根據給出的名稱，創建一個特定的管道對象。 pipeline = gst_pipeline_new (\"pipeline_name\"); 箱櫃成功創建之後，就可以調用gst_bin_add()函數將已經存在的元件添加到其中來了： GstElement *element; GstElement *bin; bin = gst_bin_new (\"bin_name\"); element = gst_element_factory_make (\"mpg123\", \"decoder\"); gst_bin_add (GST_BIN (bin), element); 而要從箱櫃中找到特定的元件也很容易，可以藉助gst_bin_get_by_name()函數實現： GstElement *element; element = gst_bin_get_by_name (GST_BIN (bin), \"decoder\"); 由於GStreamer框架中的一個箱櫃能夠添加到另一個箱櫃之中，因此有可能會出現箱櫃嵌套的情況，gst_bin_get_by_name()函數在查找元件時會對嵌套的箱櫃作遞歸查找。元件有添加到箱櫃之中以後，在需要的時候還可以從中移出，這是通過調用gst_bin_remove()函數來完成的： GstElement *element; gst_bin_remove (GST_BIN (bin), element); 如果仔細研究一下圖3中描述的箱櫃，會發現它沒有屬於自己的輸入襯墊和輸出襯墊，因此顯然是無法作為一個邏輯整體與其它元件交互的。為了解決這一問題，GStreamer引入了精靈襯墊（ghost pad）的概念，它是從箱櫃裡面所有元件的襯墊中推舉出來的，通常來講會同時選出輸入襯墊和輸出襯墊，如圖4所示： 圖4 具有精靈襯墊的箱櫃在行為上與元件是完全相同的，所有元件具有的屬性它都具有，所有針對元件能夠進行的操作也同樣能夠針對箱櫃進行，因此在GStreamer應用程序中能夠像使用元件一樣使用這類箱櫃。下面的代碼示範瞭如何為箱櫃添加一個精靈襯墊： GstElement *bin; GstElement *element; element = gst_element_factory_create (\"mad\", \"decoder\"); bin = gst_bin_new (\"bin_name\"); gst_bin_add (GST_BIN (bin), element); gst_element_add_ghost_pad (bin, gst_element_get_pad (element, \"sink\"), \"sink\"); 回頁首 二、元件連接 在引入了元件和襯墊的概念之後，GStreamer對多媒體數據的處理過程就變得非常清晰了：通過將不同元件的襯墊依次連接起來構成一條媒體處理管道，使數據在流經管道的過程能夠被各個元件正常處理，最終實現特定的多媒體功能。 圖１就描述了一條很簡單的管道，它由三個基本元件構成：數據源元件只負責產生數據，它的輸出襯墊與過濾器元件的輸入襯墊相連；過濾器元件負責從自己的輸入襯墊中獲取數據，並在經過特定的處理之後，將結果通過輸出襯墊傳給與之相連的接收器元件；接收器元件只負責接收數據，它的輸入襯墊與過濾器元件的輸出襯墊相連，負責對最終結果進行相應的處理。 GStreamer框架中的元件是通過各自的襯墊連接起來的，下面的代碼示範瞭如何將兩個元件通過襯墊連接起來，以及如何在需要的時候斷開它們之間的連接： GstPad *srcpad, *sinkpad; srcpad = gst_element_get_pad (element1, \"src\"); sinpad = gst_element_get_pad (element2, \"sink\"); //連接 gst_pad_link (srcpad, sinkpad); //斷開 gst_pad_unlink (srcpad, sinkpad); 如果需要建立起連接的元件都只有一個輸入襯墊和一個輸出襯墊，那麼更簡單的做法是調用gst_element_link()函數直接在它們之間建立起連接，或者調用gst_element_unlink()函數斷開它們之間的連接： //連接 gst_element_link (element1, element2); //斷開 gst_element_unlink (element1, element2); NULL這是所有元件的默認狀態，表明它剛剛創建，還沒有開始做任何事情。 READY表明元件已經做好準備，隨時可以開始處理流程。 PAUSED表明元件因某種原因暫時停止處理數據。 PLAYING表明元件正在進行數據處理。 所有的元件都從NULL狀態開始，依次經歷NULL、READY、PAUSED、PLAYING等狀態間的轉換。元件當前所處的狀態可以通過調用gst_element_set_state()函數進行切換： GstElement *bin; /*創建元件，並將其連接成箱櫃bin */ gst_element_set_state (bin, GST_STATE_PLAYING); 默認情況下，管道及其包含的所有元件在創建之後將處於NULL狀態，此時它們不會進行任何操作。當管道使用完畢之後，不要忘記重新將管道的狀態切換回NULL狀態，讓其中包含的所有元件能夠有機會釋放它們正在佔用的資源。 管道真正的處理流程是從第一次將其切換到READY狀態時開始的，此時管道及其包含的所有元件將做好相應的初始化工作，來為即將執行的數據處理過程做好準備。對於一個典型的元件來講，處於READY狀態時需要執行的操作包括打開媒體文件和音頻設備等，或者試圖與位於遠端的媒體服務器建立起連接。 處於READY狀態的管道一旦切換到PLAYING狀態，需要處理的多媒體數據就開始在整個管道中流動，並依次被管道中包含的各個元件進行處理，從而最終實現管道預先定義好的某種多媒體功能。 GStreamer框架也允許將管道直接從NULL狀態切換到PLAYING狀態，而不必經過中間的READY狀態。 正處於播放狀態的管道能夠隨時切換到PAUSED狀態，暫時停止管道中所有數據的流動，並能夠在需要的時候再次切換回PLAYING狀態。如果需要插入或者更改管道中的某個元件，必須先將其切換到PAUSED或者NULL狀態，元件在處於PAUSED狀態時並不會釋放其占用的資源。 由於沒有用到線程，因此必須通過不斷調用gst_bin_iterate()函數的辦法，來判斷管道的處理過程會在何時結束： while (gst_bin_iterate (GST_BIN (pipeline))); 只要管道內還會繼續有新的事件產生，gst_bin_iterate()函數就會一直返回TRUE，只有當整個處理過程都結束的時候，該函數才會返回FALSE，此時就該終止管道並釋放佔用的資源了： Manually adding or removing data from/to a pipeline synchronization, thread-safety and other things fakesink fakesrc - old version appsrc appsink - new version cap:is-live min-latency max-latency format = GST_FORMAT_TIME non-live format = GST_FORMAT_TIME or GST_FORMAT_BYTES event : SEGMENT (appsrc will push) 計算接收了多少時間用 gst_app_src_push_buffer \"max-bytes\" property “enough-data” signal “need-data” signal 錄wav gst-launch alsasrc ! audioconvert ! audio/x-raw-int,channel s=1,depth=16,width=16,rate=16000 !audioresample ! wavenc ! filesink location=mic .wav 測試播放 gst-launch audiotestsrc ! audioconvert ! audioresample ! alsasink 播放檔案 gst-launch filesrc location=toto.ogg ! decodebin ! audioconvert ! audioresample ! alsasink 即時播放錄音 gst-launch -v alsasrc ! alsasink sync=FALSE 播放mp3 gst-launch-0.10 -v filesrc location=/response.mp3 ! flump3dec ! alsasink 播放url gst-launch-0.10 playbin2 uri=http://kiis-fm.akacast.akamaistream.net/7/572/19773/v1/auth.akacast.akamaistream.net/kiis-fm null->ready->pause->playing playing->pause>ready->null Sources : filesrc | alsasrc | appsrc Sink: filesink | alsasink | appsink Encoder: Decnoder: decodebin Converter: Bin: playbin Gobject © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/5-Docker/1-Basic.html":{"url":"md/5-Docker/1-Basic.html","title":"Basic","keywords":"","body":"Basic tagsstart Docker tagsstop Introduction sudo docker run -it --privileged -v /dev/bus/usb:/dev/bus/usb ubuntu:14.04 /bin/bash sudo docker exec -u root -it compassionate_snyder bash 'su' command in Docker returns 'must be run from terminal' When you are ssh-ing in or going in via php your session is not being allocated a pty. I have used each of the following solutions: ANSWER 3: use python to spawn a pty in your shell Quite a cute hack :) jenkins@e9fbe94d4c89:~$ su - su: must be run from a terminal $ echo \"import pty; pty.spawn('/bin/bash')\" > /tmp/asdf.py $ python /tmp/asdf.py $ su - Password: root@e9fbe94d4c89:~# 什麼是 Docker Docker 是一個開源專案，誕生於 2013 年初，最初是 dotCloud 公司內部的一個業餘專案。它基於 Google 公司推出的 Go 語言實作。 專案後來加入了 Linux 基金會，遵從了 Apache 2.0 協議，原始碼在 GitHub 上進行維護。 Docker 自開源後受到廣泛的關注和討論，以至於 dotCloud 公司後來都改名為 Docker Inc。Redhat 已經在其 RHEL6.5 中集中支援 Docker；Google 也在其 PaaS 產品中廣泛應用。 Docker 專案的目標是實作輕量級的作業系統虛擬化解決方案。 Docker 的基礎是 Linux 容器（LXC）等技術。 在 LXC 的基礎上 Docker 進行了進一步的封裝，讓使用者不需要去關心容器的管理，使得操作更為簡便。使用者操作 Docker 的容器就像操作一個快速輕量級的虛擬機一樣簡單。 下面的圖片比較了 Docker 和傳統虛擬化方式的不同之處，可見容器是在作業系統層面上實作虛擬化，直接使用本地主機的作業系統，而傳統方式則是在硬體層面實作。 Image 1 - 1 Image 2 - 2 How To Install and Use Docker on Ubuntu 16.04 sudo apt-get update sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D echo \"deb https://apt.dockerproject.org/repo ubuntu-xenial main\" | sudo tee /etc/apt/sources.list.d/docker.list sudo apt-get update apt-cache policy docker-engine docker-engine: Installed: (none) Candidate: 1.11.1-0~xenial Version table: 1.11.1-0~xenial 500 500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages 1.11.0-0~xenial 500 500 https://apt.dockerproject.org/repo ubuntu-xenial/main amd64 Packages sudo apt-get install -y docker-engine sudo systemctl status docker ● docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: active (running) since Sun 2016-05-01 06:53:52 CDT; 1 weeks 3 days ago Docs: https://docs.docker.com Main PID: 749 (docker) Install ubuntu oem@Alex:~$ sudo docker pull ubuntu [sudo] password for oem: Using default tag: latest latest: Pulling from library/ubuntu f069f1d21059: Pull complete ecbeec5633cf: Pull complete ea6f18256d63: Pull complete 54bde7b02897: Pull complete Digest: sha256:bbfd93a02a8487edb60f20316ebc966ddc7aa123c2e609185450b96971020097 Status: Downloaded newer image for ubuntu:latest 列出本機映像檔 $ sudo docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 12.04 74fe38d11401 4 weeks ago 209.6 MB ubuntu precise 74fe38d11401 4 weeks ago 209.6 MB ubuntu 14.04 99ec81b80c55 4 weeks ago 266 MB ubuntu latest 99ec81b80c55 4 weeks ago 266 MB ubuntu trusty 99ec81b80c55 4 weeks ago 266 MB 創造容器 sudo docker run -ti utuntu:14.04 bash 啟動容器 sudo docker start nostalgic_hypatia 進入容器 sudo docker exec -ti nostalgic_hypatia bash sudo docker attach nostalgic_hypatia 查看容器 oem@Alex:~$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8dd510fc3be5 ubuntu:14.04 \"/bin/bash\" About a minute ago Exited (0) About a minute ago happy_fermat 091a9c73d24e ubuntu:14.04 \"/bin/bash\" 57 minutes ago Up 57 minutes gigantic_knuth 刪除容器 oem@Alex:~$ sudo docker rm happy_fermat happy_fermat cp到容器內 sudo docker cp gstreamer_example/ gigantic_knuth:/ rename容器 sudo docker rename OLD_NAME NEW_NAME scratch -> debian -> busybox 如何進到docker container file system: start container get root if [ -z \"$1\" ] ; then echo 'docker-find-root $container_id_or_name ' exit 1 fi CID=$(docker inspect --format {{.Id}} $1) if [ -n \"$CID\" ] ; then if [ -f /var/lib/docker/image/aufs/layerdb/mounts/$CID/mount-id ] ; then F1=$(cat /var/lib/docker/image/aufs/layerdb/mounts/$CID/mount-id) d1=/var/lib/docker/aufs/mnt/$F1 fi if [ ! -d \"$d1\" ] ; then d1=/var/lib/docker/aufs/diff/$CID fi echo $d1 3, cd root path © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/6-Alljoyn/1-Basic.html":{"url":"md/6-Alljoyn/1-Basic.html","title":"Basic","keywords":"","body":"Basic tagsstart Alljoyn Framework tagsstop Properties GetAllProperties GetAll - a{sv} c++ © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/6-Alljoyn/2-Gateway/1-架構說明.html":{"url":"md/6-Alljoyn/2-Gateway/1-架構說明.html","title":"架構說明","keywords":"","body":"架構說明 tagsstart Alljoyn Framework Gateway tagsstop 名詞定義 縮寫 描述 GM App Gateway Management app WKN Well-Know Name，有別於About的建立session方式 ACL Access Control List Config file 描述Alljoyn router的Policy(Allow or Deny) SLS Sessionless Signal 什麼是Alljoyn Gateway? 基於Alljoyn Framework所開發的一套Framework 主旨是快速開發一套：管理裝置行為、設定操作權限、雲端控制的一系列功能 講白一點，就是有一份XML，記錄著每個Alljoyn service內的成員們是否公開，或者是只允許被某個Alljoyn Client控制 接下來的內容，會將這份XML稱為ACL(Access Control List) Image 1 - ACL - Access Control List ACL實際上是去更新Alljoyn router的防火決策，而Alljoyn router把決策記錄在一份Configure file 將Alljoyn router視為一道防火牆，有一份通行決策(Configure file) Image 2 - Configure file ACL可以有很多份，但只有一份會生效(Activity) 在這Framework下，產生了三個負責不同職責的角色 Gateway Management app Connector app Control app 介紹一下角色的職責吧 在介紹職責之前，我必須要先講解我們想要的目標、架構與流程 我們希望可以透過網路來控制Device，無論區網或外網 區網：Control App透過Alljoyn機制直接控制Device 外網：Control App登入Cloud，並呼叫有註冊且在線的Connector來控制Device Image 3 - 架構 因此，我們需要有Control App,Connector App 再來，我想指定Alljoyn service的一部分成員公開，或只允許被某些Alljoyn Client控制 所以我要建立一份ACL，來更新Configure file 或是建立多份ACL，但只有一個生效 建立並修改ACL的工作，將交由使用者登入Control App後進行操作 基於安全因素，ACL只被允許在區網內透過Control App修改 而維護ACL，並更新Configure file的工作，交給GM app處理 Image 4 - 流程 GM App為了將當前配置上傳至Cloud，需要與Connector建立Non Session連線(透過WKN機制) 一個Connector對應一個Cloud，也對應一份目前正在運行的ACL Image 5 - 對應關係 基於安全因素，Connector與GM App是使用不同Linux User分別執行 GM App的職責是？ 管理ACL：透過About機制，使能被Control App搜尋並建立Session 更新Config File：根據ACL的啟動/關閉，來更新Config File Config File的機制為透過(Allow / Deny) Linux (User / Group) 來建立Alljoyn router Policy 提供列出ACL的Method給Connector呼叫 透過WKN與Connector建立Non Session連線 WKN是規格寫死的名稱： GM app WKN：org.alljoyn.GWAgent.GMApp Connector app WKN：org.alljoyn.GWAgent.Connector. Connector的職責是？ 與Cloud建立連線並傳輸/接收資料 在Config File允許的情況下，與Device互動 位於Cloud與Alljoyn Device的之間，將Alljoyn資料與Cloud資料做Protocol的轉換 透過GM App所發出的Signal來了解ACL是否已經被更新/刪除 透過GM App取得正在啟用的ACL Control App的職責是？ 以下所敘述的功能不一定全部包含，由服務提供商自行定義，有可能只包含一部分的功能 擁有建立/刪除/啟動/關閉/更新ACL的功能與UI介面 與服務提供商的Cloud建立User login的機制 控制Device行為 Alljoyn Router的職責是？ 正確執行Config File所記載的Policy Control App有什麼Secure機制嗎？ 由於GM App提供操作ACL的Interface必須是嚴格控管的，Control App要使用此Interface的Method前，必須輸入Password/PIN GM App應該內建Default的Password/PIN，並於Control App登入後，交由User自行修改 Image 6 - Secure Gateway的各項流程圖 Gateway Discover Image 7 - Gateway Discover 管理ACL Create ACL Image 8 - Create ACL Activate ACL Image 9 - Activate ACL Connector startup Image 10 - Connector startup Update ACL Image 11 - Update ACL Delete ACL Image 12 - Delete ACL Disable ACL Image 13 - Disable ACL Notification 送出 Notification Image 14 - 送出 Notification 接收 Notification Image 15 - 接收 Notification 控制AllJoyn Device 呼叫Method Image 16 - 呼叫Method Get property Image 17 - Get property Set property Image 18 - Set property Remoting session-based signal Image 19 - session-based signal 與ACL相關的成員 GM app管理ACL的部分 Method Create profile Activate profile Get profile GetProfileStatus GetProfileList Update profile Delete profile Deactivate profile Connector提供給外網的部分 Method Get profile Update connection status Signal Profile updated Profile deleted Shutdown App Config File Config File內的Policy應該要使GM App能收到所有設備的About(Default) GM App啟動時，應該基於已經安裝的Connector ID，建立Deny-all的Policy GM App應該根據ACL修改Config File內的Policy 當Active的ACL被Disable或是Delete時，GM App要移除與此ACL相關的Policy Policy可以Allow/Deny Connector發出Notification Policy可以Allow/Deny Connector接收某Device的Notification Policy可以Allow/Deny Connector對發出Signal Policy可以Allow/Deny Connector接收某Device的Signal Policy可以Allow/Deny Connector呼叫某Device的Method Config File的Policy會隨著Runtime而不斷改變 Config File的Reload有兩種方法，一種是取得Bus的ProxyBusObject並引用其Interface的Method；另一種是發送平台訊號(如Kill xxx)來觸發 GM App採用前者的方式 Connetor與Cloud的架構與設計 架構 服務提供商在Cloud端建立App Download Server，管理所有可供下載的Connector Package Control App於User login Cloud後，提供UI介面，便於User從App Download Server下載Connector Package，且提Install/Upgrade等UI介面。 基於上面的需求，GM App必須提供一個Interface給Control App，以便管理Connector Package的Install/Upgrade/Uninstall/Restart 基於安全考量，應由Package Manager(PM)管理需要安裝的Connector Package並驗證數位簽章是否符合 PM與GM App互動的實作與細節不在此討論內。 Image 20 - Cloud & Connector Install或其他Method被呼叫時，實際上Control App將URL傳給GM App，並交由PM下載、驗證、安裝並分配一個唯一Linux User給此Connector Package當作識別 每一個被安裝的Connector Package都有被分配到一個唯一的Linux User Connector Package被分配到的Linux User都屬於同一個Group GM App應該將已經安裝的Connector Package紀錄成一個表格，包含 Connector Id App Name App Package Name App version App package File URL App User Id App Group Id Install Status Install Description Connection Status Operational Status 所有Connector Package內，在預定位置必須含有manifest file，來描述此Connector提供的Service，以及預期能與之互動的Interface 設計細節 App Management interface Method Install App Uninstall App Restart App Get App Status Get Installed Apps Get Manifest Data Get Manifest Interfaces Signal App Status Changed Package Manager app functions Method Install App Uninstall App Manifest file Install App App Package Name App version Min AJ SDK version exposed Services List execution Info 外部連結： Alljoyn Gateway wiki © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/6-Alljoyn/2-Gateway/2-啟動流程 & 程式碼.html":{"url":"md/6-Alljoyn/2-Gateway/2-啟動流程 & 程式碼.html","title":"啟動流程 & 程式碼","keywords":"","body":"啟動流程 & 程式碼 tagsstart Alljoyn Framework Gateway tagsstop 名詞定義 縮寫 描述 GM App Gateway Management app WKN Well-Know Name，有別於About的建立session方式 ACL Access Control List Config file 描述Alljoyn router的Policy(Allow or Deny) SLS Sessionless Signal Connector Code Initialize Bus At tachment：Start & Connect BusAttachment* bus = new BusAttachment(\"ConnectorApp\", true); bus->Start(); bus->Connect(); Initialize authentication：EnablePeerSecurity這個函數是用來啟動身分驗證與加密機制，使用前需要先Start。 keyListener.setPassCode(\"000000\"); String keystore = \"/opt/alljoyn/apps/\" + wellknownName + \"/store/.alljoyn_keystore.ks\"; bus.EnablePeerSecurity(\"ALLJOYN_PIN_KEYX ALLJOYN_SRP_KEYX ALLJOYN_ECDHE_PSK\", &keyListener, keystore.c_str(), false); 這裡所出現的keyListener是一種自定類別，繼承自AuthListener。 class SrpKeyXListener : public ajn::AuthListener SrpKeyXListener keyListener; 而AuthListener為啟動驗證機制時，負責傳達Password或其他與驗證機制相關的Class。 繼承AuthListener時，有幾種virtual method可以實作，其中比較常用的有RequestCredentials/AuthenticationComplete virtual bool RequestCredentials (const char *authMechanism, const char *peerName, uint16_t authCount, const char *userName, uint16_t credMask, >>Credentials &credentials) virtual void AuthenticationComplete (const char *authMechanism, const >>char *peerName, bool success)=0 以下用SrpKeyXListener改寫的內容做為範例： 首先是RequestCredentials bool SrpKeyXListener::RequestCredentials(const char* authMechanism, const char* authPeer,uint16_t authCount, const char* userId, uint16_t credMask, Credentials& creds) { std::cout 其中Credentials為AuthListener的Inner class，作為傳遞認證資訊的關鍵角色。 再來是AuthenticationComplete void SrpKeyXListener::AuthenticationComplete(const char* authMechanism, const char* authPeer, bool success) { std::cout 此處只有一行cout，表明認證結果。 當Interface的secure設為True，第一次調用此Interface下的任何member，都會產生認證要求。 以下是上述Code的認證執行輸出： RequestCredentials for authenticating org.alljoyn.GWAgent.GMApp using mechanism ALLJOYN_ECDHE_PSK RequestCredentials setPasscode to 000000 Authentication with ALLJOYN_ECDHE_PSK was successful Initialize Connector class MyApp : public GatewayConnector MyApp myApp(&bus, wellknownName.c_str()); myApp.init(); 繼承GatewayConnector時，有幾項Method需要實作。 virtual void shutdown() {…} virtual void mergedAclUpdated() {…} void receiveGetMergedAclAsync(QStatus unmarshalStatus,GatewayMergedAcl* response) {…} 基本上到目前為止，就已經完成一個Connector了。接著只需要跟Cloud互動，並在互動過程中適時的呼叫myApp.updateConnectionStatus(...)回報給GM App目前與雲端的連接狀態。GM App收到後，會發Signal給Controler，Controler收到後會呼叫GM AppInterface的Method取得狀態。 GatewayConnector這個Class透過WKN取得GM App的ProxyBusObject，其內部有2個Method與3個Signal，需要RegisterSignalHandler。 ifc->AddMethod(\"GetMergedAcl\", NULL, \"a(obas)a(saya(obas))\", \"exposedServices,remotedApps\"); ifc->AddMethod(\"UpdateConnectionStatus\", \"q\", NULL, \"connectionStatus\", MEMBER_ANNOTATE_NO_REPLY); ifc->AddSignal(\"MergedAclUpdated\", NULL, NULL); ifc->AddSignal(\"ShutdownApp\", NULL, NULL); Manifest.xml Build好Connector後的下一個工作，就是建置Manifest.xml了。Manifest.xml描述Connector的Service、感興趣的Interface、Connector執行時的參數傳入。 是之後Control App用以建立ACL的依據。 以下為Manifest.xml範例結構。 dummyapp1 dummyAppOne dummyAppOne_0.0.1-1_ar71xx.ipk 0.0.1 3.4.0 /emergency false org.alljoyn.Notification /warning false org.alljoyn.Notification / true org.alljoyn.Notification org.alljoyn.About org.alljoyn.Icon org.alljoyn.NotificationSuper org.alljoyn.Config alljoyn-gwconnectorsample /opt/alljoyn/apps/dummyapp1/lib 7 1 postTweet.sh 安裝Connector 有了Build好的Connector與Manifest.xml以後，接著就是安裝/移除Connector了。 安裝的第一步就是將lib、bin、Manifest.xml依照下列格式擺放。 之後將整包壓縮成一個tar檔案。 tar czf dummyApp1.tar.gz -C gatewayConnector/tar Image 1 - Alt text 接著透過官方提供的installPackage.sh/removePackage.sh進行安裝/移除 ./installPackage.sh dummyApp1.tar.gz installPackage.sh所做的事情很單純， 只是將tar檔裡的東西轉移到/opt/alljoyn/apps/$connectorId之中，然後創造一個Linux User，並將store這個Folder的擁有者，轉移到新創的Linux User下 baseDir=/opt/alljoyn manifestFile=$tmpDir/Manifest.xml appBinDir=$tmpDir/bin connectorId=$(grep \"\" $manifestFile | sed -e \"s/ *//\" | sed -e \"s///\") connectorAppDir=$baseDir/apps/$connectorId if [ $? -ne 0 ]; then useradd $connectorId || exit 22 createdUser=1 fi chown -R \"$connectorId\" \"$pkgInstallDir/store\" || exit 23 chmod -R a+rx \"$pkgInstallDir/bin\" || exit 24 chmod -R a+rx \"$pkgInstallDir/lib\" || exit 25 經過上面安裝後，就會看到/opt/alljoyn/apps/$connectorId目錄，結構如下。 此時acls Folder內無東西。可以透過shell自行創造，或是啟動GM App與Controller App後，透過Contorller App建立。 啟動 啟動Router 在啟動GM App與Connectors之前，先確定alljoyn-daemon是否已經安裝並啟動。 先確認是否Build好的alljoyn-daemon放在/usr/bin/中，並寫好alljoyn.init放在/etc/init.d/alljoyn之中。之後執行service alljoyn start 以下為alljoyn.init的start script start() { if [ -f $PIDFILE ] && kill -0 $(cat $PIDFILE); then echo 'Service already running' >&2 return 1 fi echo 'Starting service…' >&2 local CMD=\"$SCRIPT --config-file=/opt/alljoyn/alljoyn-daemon.d/config.xml &> \\\"$LOGFILE\\\" & echo \\$!\" su -c \"$CMD\" $RUNAS > \"$PIDFILE\" echo 'Service started' >&2 } 執行時所帶的參數--config-file指出Router Config Policy的位置，此例為/opt/alljoyn/alljoyn-daemon.d/config.xml 注意Config File內，要include GM App執行時動態改變的Policy File，此例為gwagent-config.xml alljoyn org.alljoyn.BusNode unix:abstract=alljoyn tcp:r4addr=0.0.0.0,r4port=0 5000 16 100 100 false /opt/alljoyn/alljoyn-daemon.d/gwagent-config.xml Config File內所有可用的的Tag，與每個Tag的說明，請參閱以下網址。 XML Schema Routing Node Configuration File 確認完成後，執行Router：service alljoyn start 啟動GM App 確認Config File 與start alljoyn-daemon以後，對於GM App我們也依法照做一次。 將Build好的alljoyn-gwagent放在/usr/bin/中，並寫好alljoyn-gwagent.init放在/etc/init.d/alljoyn-gwagent之中。之後執行service alljoyn-gwagent start 以下為alljoyn-gwagent.init的start script start() { if [ -f $PIDFILE ] && kill -0 $(cat $PIDFILE); then echo 'Service already running' >&2 return 1 fi echo 'Starting service…' >&2 local CMD=\"$SCRIPT &> \\\"$LOGFILE\\\" & echo \\$!\" su -c \"$CMD\" $RUNAS > \"$PIDFILE\" echo 'Service started' >&2 } 注意：雖然此例沒有使用，但事實上可以帶入參數--gwagent-policy-file指出GM App執行時動態產生的Config File，以及--apps-policy-dir指出根據ACL產生的Config File Folder 以下為GM App程式碼片段 String policyFileOption = \"--gwagent-policy-file=\"; String appsPolicyDirOption = \"--apps-policy-dir=\"; for (int i = 1; i setGatewayPolicyFile(policyFile.c_str()); } if (arg.compare(0, appsPolicyDirOption.size(), appsPolicyDirOption) == 0) { String policyDir = arg.substr(appsPolicyDirOption.size()); QCC_DbgPrintf((\"Setting appsPolicyDir to: %s\", policyDir.c_str())); gatewayMgmt->setAppPolicyDir(policyDir.c_str()); } } 例如： start() { service_start /usr/bin/alljoyn-gwagent `--gwagent-policy-file`=/etc/alljoyn/gwagent/gwagent.conf `--apps-policy-dir`=/etc/alljoyn/gwagent-apps } 如果沒有特別指明，則Default gwagent-policy-file：/opt/alljoyn/alljoyn-daemon.d/gwagent-config.xml apps-policy-dir：/opt/alljoyn/alljoyn-daemon.d/apps static const qcc::String GATEWAY_POLICIES_DIRECTORY = \"/opt/alljoyn/alljoyn-daemon.d\"; GatewayRouterPolicyManager::GatewayRouterPolicyManager() : m_AboutListenerRegistered(false), m_AutoCommit(false), m_gatewayPolicyFile(GATEWAY_POLICIES_DIRECTORY + \"/gwagent-config.xml\"), m_appPolicyDirectory(GATEWAY_POLICIES_DIRECTORY + \"/apps\") { } 下圖為此範例的目錄結構： config.xml： gwagent-config.xml： apps-policy-dir內的dummyapp1.xml： 確認完成後，執行GM App：service alljoyn-gwagent start 驗證 透過ps -ef | grep alljoyn指令驗證 目錄結構 /opt/alljoyn下的樹狀結構： Controller App畫面 進入搜尋到的GM App： 進入Connector's acl列表 允許Connector的服務： 含有此Connector感興趣的Interface的Device： 允許Connector存取此Device： ACL產生： 同時產生Config Policy： © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/6-Alljoyn/3-Allplay.html":{"url":"md/6-Alljoyn/3-Allplay.html","title":"Allplay","keywords":"","body":"Alljoyn - Allplay tagsstart Alljoyn Framework Allplay tagsstop 核心 BusObject Path: /net/allplay/MediaPlayer Interface: net.allplay.MediaPlayer 附加 BusObject Path: /net/allplay/MediaPlayer Interface: net.allplay.ZoneManager Interface: org.alljoyn.Control.Volume BusObject Path: /net/allplay/MediaPlayer/Playlist Interface: net.allplay.Playlist net.allplay.MediaPlayer XML Method Play Pause Resume Stop Previous Next SetPosition GetPlayerInfo GetPlaylist GetPlaylistInfo ForcedPrevious Properties EnabledControls Interruptible LoopMode PlayState ShuffleMode Version Signal EnabledControlsChanged EndOfPlayback InterruptibleChanged LoopModeChanged ShuffleMode Version Scenario start GetPlayerInfo GetEnabledControls GetInterruptible GetLoopMode GetPlayState GetShuffleMode GetVersion GetPlaylist() 設定撥放位置 Method - SetPosition(INT64 positionMsecs) signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state 隨機撥放 Set - ShuffleMode - STRING SHUFFLE LINEAR signal - ShuffleModeChanged - STRING shuffleMode 循環模式 Set - LoopMode - STRING ONE NONE ALL signal - LoopModeChanged - STRING loopMode Resume Method - Resume() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state 新增歌曲到Playlist Method - UpdatePlaylist playlistItems public string Album { get; set; } public string Artist { get; set; } public long Duration { get; set; } public string Genre { get; set; } public string MediaType { get; set; } public IDictionary MediumDesc { get; set; } public IDictionary OtherData { get; set; } public string ThumbnailUrl { get; set; } public string Title { get; set; } public string Url { get; set; } public object UserData { get; set; } ` Album=幸福了 然後呢 Duration=286000 Genre=Pop Artist=A-Lin & 小宇 MediaType=audio MediumDesc=System.ComObject OtherData=System.ComObject ThumbnailUrl=http://192.168.1.20:10508/download/thumb.jpg?id=8285275079956195101 Title=920 Url=http://192.168.1.20:10508/download/item.mp3?id=8285275079956195101` signal - PlayListChanged - VOID Method - GetPlaylist Method - Play() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state Pause Method - Pause() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state Next Method - Next() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state Previous Method - Previous() signal - PlayStateChanged - sxuuuiia(ssssxsssa{ss}a{sv}v) state 移除PlayList Method - UpdatePlaylist Method - GetPlaylist signal - PlayListChanged - VOID 連線失敗 signal - OnPlaybackError - Volume 調整音量 Set - Volume - INT16 Volume : 0~100 signal - VolumeChanged - INT16 newVolume newVolume : 0-100 Pega-Gateway Event Play In { \"itemIndex\":Int \"startPositionMsecs\":Int64 \"pauseStateOnly\":Bool } Out {} Previous In {} Out {} Pause In {} Out {} Resume In {} Out {} Stop In {} Out {} Next In {} Out {} UpdatePlaylist In { \"playlistItems\": [ { \"url\":String \"title\":String \"artist\":String \"thumbnail_url\":String \"duration\":Int64 \"mediaType\":String \"album\":String \"genre\":String \"other_data\": { String:String } \"medium_description\": { String:??? } \"userData\":??? } ] \"index\":Int \"controllerType\":String \"playlistUserData\":String } Out {} SetPosition In { \"positionMsecs\":Int64 } Out {} ForcedPrevious In {} Out {} CreateZone In { \"players\": [ String ] } Out { \"zoneId\":String \"timestamp\":Int \"failedPlayers\": { String:Int } } SetZoneLead In { \"zoneId\":String \"timeServerIp\":String \"timeServerPort\":Uint16 } Out { \"timestamp\":Int } Pega-Gateway Get-Parameter GetPlayerInfo { \"displayName\":String \"capabilities\": [ String ] \"maximumVolume\":Int \"zoneInfo\": { \"zoneId\":String \"zone_timestamp\":Int \"player_known_name\":??? } } GetPlaylist { \"items\": [ { \"url\":String \"title\":String \"artist\":String \"thumbnail_url\":String \"duration\":Int64 \"mediaType\":String \"album\":String \"genre\":String \"other_data\": { String:String } \"medium_description\": { String:??? } \"userData\":??? } ] \"controllerType\":String \"playlistUserData\":String } GetPlaylistInfo { \"controllerType\":String \"playlistUserData\":String } GetPlayState { \"playstate\":String \"position\":Int64 \"current_sample_rate\":uint32 \"audio_channels\":uint32 \"bits_per_sample\":uint32 \"index_current_item\":Int64 \"index_next_item\":Int64 \"items\": [ { \"url\":String \"title\":String \"artist\":String \"thumbnail_url\":String \"duration\":Int64 \"mediaType\":String \"album\":String \"genre\":String \"other_data\": { String:String } \"medium_description\": { String:??? } \"userData\":??? } ] } EnabledControls: [ \"???\":String \"???\":Bool ] GetInterruptible:Bool GetLoopMode : String (ONE,ALL,NONE) GetShuffleMode : String (LINEAR,SHUFFLE) GetAllplayVersion : Uint16 GetVolume : Int16 GetMute : Bool GetVolumeRange : { \"Low\":Int16 \"High\":Int16 \"Increment\":Int16 } GetVolumeEnabled : Bool GetZoneManagerEnabled:Bool Pega-Gateway Set-Parameter SetLoopMode : String (ONE,ALL,NONE) SetShuffleMode : String (LINEAR,SHUFFLE) SetVolume : Int16 SetMute : Bool © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/7-CMake/1-Basic.html":{"url":"md/7-CMake/1-Basic.html","title":"Basic","keywords":"","body":"Basic tagsstart cmake tagsstop Target properties file(GLOB gateway_lib_c ${gateway_sources}/*.c) list(REMOVE_ITEM gateway_lib_c \"${gateway_sources}/main.c\") unset(dep_library CACHE) find_library(dep_library NAMES ${dep} HINTS ${CMAKE_CURRENT_SOURCE_DIR}/../build/${CMAKE_SYSTEM_NAME}/${TARGET_ARCHITECTURE}/${CMAKE_BUILD_TYPE}/deps/${dep}/lib ) TARGET_LINK_LIBRARIES(${PROJECT_NAME}_bin ${dep_library}) PERMISSIONS，用以指定檔案存取權限，可用的選項有 OWNER_READ、OWNER_WRITE、OWNER_EXECUTE、GROUP_READ、GROUP_WRITE、 GROUP_EXECUTE、WORLD_READ、WORLD_WRITE、WORLD_EXECUTE、SETUID、SETGID。在不支援這些權限設定的平台上會自動忽略。 EXECUTE_PROCESS( COMMAND command COMMAND tr -d '\\n' OUTPUT_VARIABLE ARCHITECTURE ) message( STATUS \"Architecture: ${ARCHITECTURE}\" ) include(${CMAKE_CURRENT_SOURCE_DIR}/../A/CMakeLists.txt) TARGET_LINK_LIBRARIES(myProject hello)，连接libhello.so库 TARGET_LINK_LIBRARIES(myProject libhello.a) TARGET_LINK_LIBRARIES(myProject libhello.so) TARGET_LINK_LIBRARIES(myProject -lhello) set(V alpha beta gamma) message(${V}) foreach(i ${V}) message(${i}) endforeach() CMAKE_CURRENT_SOURCE_DIR 目前正在處理的 CMakeLists.txt 所在位置。 CMAKE_CURRENT_BINARY_DIR 目前正在處理的 CMakeLists.txt 對應的建置資料夾位置。當然，在 in-source build 時和 CMAKE_CURRENT_SOURCE_DIR 相同。 CMAKE_BINARY_DIR © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/7-CMake/2-Target.html":{"url":"md/7-CMake/2-Target.html","title":"Target","keywords":"","body":"Target tagsstart cmake tagsstop Target properties INTERFACE_INCLUDE_DIRECTORIES 若此Target為Library，則此Property代表public include directories的List Target B若link到此Target A，則 Target B會自動includeTarget AProperty中INTERFACE_INCLUDE_DIRECTORIES所指向的directories， 因此不必再特別設定include_directories 可以透過set_target_properties設定 set_target_properties(${TargetName} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES ${PROJECT_SOURCE_DIR}/inc ) 若target_include_directories()指令中，值被設定為PUBLIC或是INTERFACE，則 target_include_directories()內的設定值會自動加入INTERFACE_INCLUDE_DIRECTORIES target_include_directories 說明 target_include_directories( [SYSTEM] [BEFORE] [items1...] [ [items2...] ...]) 為Target添加include directories PUBLIC, PRIVATE and INTERFACE此3個為Keyword PUBLIC: 會將target_include_directories()的值發佈到INCLUDE_DIRECTORIES與INTERFACE_INCLUDE_DIRECTORIES PRIVATE: 會將target_include_directories()的值發佈到INCLUDE_DIRECTORIES INTERFACE: 會將target_include_directories()的值發佈到INTERFACE_INCLUDE_DIRECTORIES Directory ├── CMakeLists.txt ├── foo │ ├── CMakeLists.txt │ ├── src │ │ └── foo.c │ └── inc │ └── foo.h └── bar ├── CMakeLists.txt └── src └── bar.c Root CMakeLists.txtcmake_minimum_required(VERSION 2.8) add_subdirectory(foo) add_subdirectory(bar) Foo foo/CMakeLists.txtfoo/src/foo.cfoo/inc/foo.hcmake_minimum_required(VERSION 2.8) project(Foo) add_library(foo SHARED src/foo.c) target_include_directories(foo PUBLIC ${PROJECT_SOURCE_DIR}/inc ) # target_include_directories(foo PRIVATE # ${PROJECT_SOURCE_DIR}/inc # ) # set_target_properties(foo # PROPERTIES # INTERFACE_INCLUDE_DIRECTORIES ${PROJECT_SOURCE_DIR}/inc # )#include \"foo/foo.h\" #include void foo(void) { \tprintf(\"This is foo version %s\\n\", \"1.0\"); }#pragma once #ifndef FOOBAR_FOO_H #define FOOBAR_FOO_H void foo(void); #endif 若將target_include_directories(PUBLIC) 改為以下： target_include_directories(foo PRIVATE ${PROJECT_SOURCE_DIR}/inc ) 會造成build bar.c失敗 => bar/src/bar.c:2:21: fatalerror: foo/foo.h: 沒有此一檔案或目錄∵沒有設定INTERFACE_INCLUDE_DIRECTORIES∴Target bar找不到Target foo需要的include directories 若改為以下： set_target_properties(foo PROPERTIES INTERFACE_INCLUDE_DIRECTORIES ${PROJECT_SOURCE_DIR}/inc ) 會造成build foo.c失敗 => foo/src/foo.c:2:21: fatal error: foo/foo.h: 沒有此一檔案或目錄∵沒有設定INCLUDE_DIRECTORIES∴Target foo找不到需要的include directories 在這個範例看不出使用set_target_properties來設置INTERFACE_INCLUDE_DIRECTORIES的好處， 那麼什麼時候會需要用到呢？ 等我們講到Importing Targets的時候，set_target_properties就非用不可了。 Importing Targets： 將外部已經build好的library(.a or .so)或是executable file(.exe)， 引入到當前CMake的Project中，使其成為一個邏輯上的Target。 由於這類的Target無法使用target_include_directories()， 此時便需要set_target_properties來設置INTERFACE_INCLUDE_DIRECTORIES add_library( External_lib SHARED IMPORTED GLOBAL ) set_target_properties( External_lib PROPERTIES IMPORTED_LOCATION /path/to/libExternal_lib.so INTERFACE_INCLUDE_DIRECTORIES /path/to/External_lib/include ) Bar bar/CMakeLists.txtbar/src/bar.ccmake_minimum_required(VERSION 2.8) project(Bar) add_executable(bar src/bar.c) target_link_libraries(bar foo )#include \"foo/foo.h\" int main(int argc, char* argv[]) { \tfoo(); \treturn 0; } Result Image 1 - cmake && make Image 2 - run © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/8-Memory/1-valgrind.html":{"url":"md/8-Memory/1-valgrind.html","title":"Valgrind","keywords":"","body":"valgrind tagsstart valgrind memory tagsstop Introduction Memory Leak: leak on the heap, memory allocation during runtime Frequent Memory Leak: a code include memory leak is used frequently (most dangerous but relatively easy to find) Occasional Memory Leak: memory leak happens in specific occasion (hard to find) One-Time Memory Leak: only leak once, like in a singleton class (not that dangerous) Implicit Memory Leak: always allocate memory during the runtime and only free memory until exit (hard to find and dangerous, may hold too much memory and lead to crush ) Examples Forget to free/delete void func() { char *oldString = \"Old String\"; char* newStrig = strdup(oldString); //be careful with c lib-functions which alloc memory inside char *textString = malloc(128*sizeof(char)); ClassTypeA *ptr = new ClassTypeA; return; } Be careful with logic branches BassClass * obj = new BaseClass； if（test something） return; else if (test something) do something; else do something; delete obj; return; 2.Careful with Inheritance, polymorphism BaseClass* obj_ptr = new DerivedClass; delete obj_ptr; /*If you are counting on the destructor to delete memory allocated in the constructor beware of this mistake as it will cause a memory leak. */ /*Use a virtual destructor to avoid this problem.*/ 3.Pointer re-assignment error char *a = malloc(128*sizeof(char)); char *b = malloc(128*sizeof(char)); b = a; free(a); free(b); // will not free the pointer to the original allocated memory. 4.Default copy constructor may not give correct results ClassA& operator=(const ClassA& right_hand_side); /*sallow copy, deep copy?*/ /*Memory allocated by copy constructors for pointer duplication. Check in destructor and delete if necessary. Memory allocated in passing class by value which invokes copy constructor. Also beware, the default copy constructor may not give you the results you want especially when dealing with pointers as the default copy constructor has no knowledge of how to copy the contents of what the pointer points to. To prohibit the use of the default copy constructor define a null assignment operator. And when there is allocation in class, define your own destructor*/ class GCharacter //Game Character { private: std::string name; int capacity; //the capacity of our tool array int used; //the nr of elements that we've actually used in that tool array std::string* toolHolder; //string pointer that will be able to reference our ToolArray; public: static const int DEFAULT_CAPACITY = 5; //Constructor GCharacter(std::string n = \"John\", int cap = DEFAULT_CAPACITY) :name(n), capacity(cap), used(0), toolHolder(new string[cap]) { } } int main() { GCharacter gc1(\"BoB\", 5); GCharacter gc2(\"Terry\", 5); gc2 = gc1; GCharacter gc3 = gc1; return 0; } Do not rely on STL containers vector objects; for (int i=0;i Yes, stl containers will call destruct functions. But in this case, the container dose not free any memory. vector objects; //when clear object in vector, the vector will call the destructor of T in this way *T->~T(); Implicit Memory Leak: free memory as soon as you don't need it(or need so large) another stl example: stl containers always know how and when to expand itself, but they never know when to shrink itself. { vector vec; for(int64_t i=0; i then the 1000000000000000000*sizeof(int) memory will hold forever. //if you don't need it vector().swap(vec) //instead of clear //if you want to shrink the container size vector(vec).swap(vec) Implicit Memory Leak: heap fragmentation（impossible to be found by tools） You think the code is memory leak free, but the memory usage always going up and then crush.... Applications that are free from memory leaks but perform dynamic memory allocation and deallocation frequently tend to show gradual performance degradation if they are kept running for long periods. Finally, they crash. Why is this? Recurrent allocation and deallocation of dynamic memory causes the heap to become fragmented, especially if the application allocates small memory chunks (int, an 8 byte object etc.). A fragmented heap can have many free blocks, but these blocks are small and non-contiguous. imagine that you have a \"large\" (32 bytes) expanse of free memory: | | Now, allocate some of it (5 allocations): |aaaabbccccccddeeee | Now, free the first four allocations but not the fifth: | eeee | Now, try to allocate 16 bytes. Oops, I can't, even though there's nearly double that much free. On systems with virtual memory, fragmentation is less of a problem than you might think, because large allocations only need to be contiguous in virtual address space, not in physical address space. So in my example, if I had virtual memory with a page size of 2 bytes then I could make my 16 byte allocation with no problem. Physical memory would look like this: | ffffffffffffffeeeeff | whereas virtual memory (being much bigger) could look like this: ------------------------------------------------------... | eeeeffffffffffffffff ------------------------------------------------------... The classic symptom of memory fragmentation is that you try to allocate a large block and you can't, even though you appear to have enough memory free. Another possible consequence is the inability of the process to release memory back to the OS (because there's some object still in use in all the blocks it has allocated from the OS, even though those blocks are now mostly unused). Method to avoid: 1.First of all, use dynamic memory as little as possible. In most cases, you can use static or automatic storage instead of allocating objects dynamically. 2.Secondly, try to allocate large chunks rather than small ones. For example, instead of allocating a single object, allocate an array of objects at once, and use these objects when they are needed. (Like use reserve() for stl containers) If all these tips don't solve the fragmentation problem, you should consider building a custom memory pool. Implicit Memory Leak: memory not release to OS When you call free() or delete(), it will NOT really release any memory back to OS. Instead, that memory is kept with the same process until it is terminated. However, this memory can be reused for any future allocations by the same process. documentation for libc's free: Occasionally, free can actually return memory to the operating system and make the process smaller. Usually, all it can do is allow a later call to malloc to reuse the space. In the meantime, the space remains in your program as part of a free-list used internally by malloc. a little deeper by looking at other malloc/free family of functions and saw 'mallopt', and that you can actually change the way malloc/free behave (especially if you're using GNU libc -- pointers about other platform implementations would be helpful). One option that is interesting to look at is M_TRIM_THRESHOLD which: This is the minimum size (in bytes) of the top-most, releasable chunk that will cause sbrk to be called with a negative argument in order to return memory to the system. 昨天晚上，我徒弟跑过来讲，他的程序的内存占用居高不下，愿意是std::map的clear()没有效果。于是我让他用erase(begin,end); 试试也不行。 代码如下： View Code 用命令 top -p ps -ef | grep abc | grep -v grep | awk {'print $2'}, 一查看，占了104M物理内存。 开始我猜测是stl用了自己的缓冲池，clear()并没有归还给系统。于是我用了boost::unordered_map试试，一查看，占了78M物理内存（看来hashmap比红黑树既快又省空间）。 于是上网查询资料，stl有很多种allocator，默认采用是的new_allocator，并没有使用内存缓冲池，针对不同的应用场合，STL中实现了不同的Allocator。 gnu_cxx::new_allocator Simply wraps ::operator new and ::operator delete. gnu_cxx::malloc_allocator Simply wraps malloc and free. There is also a hook for an out-of-memory handler gnu_cxx::debug_allocator A wrapper around an arbitrary allocator A. It passes on slightly increased size requests to A, and uses the extra memory to store size information. gnu_cxx::pool_alloc A high-performance, single pool allocator. The reusable memory is shared among identical instantiations of this type. gnu_cxx::mt_alloc A high-performance fixed-size allocatorthat was initially developed specifically to suit the needs of multi threaded applications gnu_cxx::bitmap_allocato A high-performance allocator that uses a bit-map to keep track of the used and unused memory locations 发现stl提供的malloc.h有监控功能，于是修改为下面代码： #include #include #include #include #include using namespace std; using namespace boost; void release_map(void) { malloc_stats(); map testmap; sleep(2); for(int i=0; i 发现clear() 其实已经归还内存了，内存的持有是 system bytes 。显然，malloc并没有把这些内存归还给系统，而是缓存起来了。所以说，这个例子的罪魁祸首并不是STL，而是glibc的malloc。好吧，既然找到问题，那就要解决它，虽然glibc的缓存也是一番好意，但是由于实际运行环境不能等到什么用户heap空间内连续空闲内存数据超出一个阈值时才将这片内存归还给内核。 glibc管理内存目前采用的是ptmalloc2，我测试了google的tcmalloc和Jason Evans的jemalloc。 测试很简单，把包downlaod下来并解压，./configure && make && make install即可。 export $LD_PRELOAD=\"/usr/local/lib/libtcmalloc.so” 或者 export $LD_PRELOAD=\"/usr/local/lib/libjemalloc.so” (这个要根据自己的实际情况选择路径) 然后编译后可以用ldd查看程序的依赖库。 测试结果：tcmalloc也不归还给系统，而jemalloc的clear后不再占用物理内存。 徒弟问了一句jemalloc靠谱么，我想想淘宝的Tengine，facebook的folly，redis，firefox，freebsd都是用这个，应该是很靠谱的。你上线去测试看看。 附上一张内存分配性能比较图片： Image 1 - Performance valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./pega_iot_gateway_bin hello_world_lin.json 可以看到 memory lost 分成幾種類型： definitely lost: 真的 memory leak 了 indirectly lost: 間接的 memory leak，structure 本身發生 memory leak，而內部的 member 如果是 allocate 的出來的，一樣會 memory leak，但是只要修好前面的問題，後面的問題也會跟著修復 possibly lost: allocate 一塊記憶體，並且放到指標 ptr，但事後又改變 ptr 指到這會計一體的中間 (這一點我目前也不是很清楚，建議看原文說明) still reachable: 程式結束時有未釋放的記憶體，不過卻還有指標指著，通常會發生在 global 變數 如果不想 show possibly lost，可以加下面的參數 3.9版 --show-leak-kinds=definite 3.7版 --show-possibly-lost=no © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/9-GoogleCloud/1-Speech.html":{"url":"md/9-GoogleCloud/1-Speech.html","title":"Speech","keywords":"","body":"Basic tagsstart Google Cloud Speech API tagsstop Request { \"config\": { \"encoding\":\"FLAC\", \"sample_rate\": 16000 }, \"audio\": { \"uri\":\"gs://cloud-samples-tests/speech/brooklyn.flac\" } } 授權 建立資料庫 $ gcloud auth activate-service-account --key-file=service-account-key-file from json file: { \"type\": \"service_account\", \"project_id\": \"zhenkun-957\", \"private_key_id\": \"d19f1f372bdb4493f05fd8d636aa3218f0b9c2a1\", \"private_key\": \"-----BEGIN PRIVATE KEY-----\\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDDTnzisZPMhds6\\nYUvlyuIUXmB84/zONIkvKLIGhkDXpkmWF6xDGV76RBSMTPu3PGJBwB1hFE2Xetqa\\nnTo0nDFetZe6oVb8g6Yr1aHtSTAYIdtrQIwSXDZaX+6eiY7tA8hy2oXZERWoVbio\\nTVnI4Ga+5hcqeGGRj31IXmm6z1254o3uOBq6+6Q3GmghjTPcVJyxRdpztWbivJuY\\n9CWOqAKZTFTSJ4qPTb7V4smUdYkdWPXdfbKLFs3fy8rES4C7lQNQ57LS36MnxcPm\\niQuuRzDvGdLkOVosTJ3qLDMDGmR8WPau6SGNURNFyNPRjCcTkrntgNbT8y/QqPCE\\ni0P6KenLAgMBAAECggEAZdR0dNXVk9tu1F+KbQN9INWcRUGxu+nUZQw41gIFqOqA\\nj4tEO6/sv1vjwssYqw8Gw/Vg3A7z7bkWZWr4wBl3/EN+GsaoTfxuFYjLZqa0NsDg\\nYGlFHwWJKVG/XlWmeZlxV8Dr7KNlwWEAaG/8Eio+J+Zbyb7+UCCaV7MyOT6JRbMa\\nyiEVTX7JZ/l1c7AhrJ5s8UaZtcxSNNlhV4hC+zJ8DU4eq3bu+66xvit0io6Ymmog\\nDT7chh2SP25b95TUSnZfAxWvvC532viDonyYwYZ9CWt+aBNkWGTuIFZYd6IeC4vH\\nKbLH7f3qbLVFrFQZKQb0urCumWkHFS7ndFYY6TdaQQKBgQDkCwF6L4zMShB96WG7\\nVv8XUJptqd54QVWtlVdeYgdN7TGYescDifQyd33ufDahiTrHv0W0ih4QQQeZd77f\\np/QYuVHdFhMm9UYZq2iVAYBTE9FhomG1rn7BfzTvJI8VEQcAlHMDHn7qtGDtuI5v\\nHjyZPW92ewnp450bEMZ/L/6pGwKBgQDbQBHQ4N7bO07j32SvIazlO1z2O5jeaLxt\\nLPiQyWxfYq6Y2PnPNW+BCM/Zvv45sqJ4NANyBE/1k9qCE+OkRgeLic9Sbz2VWC4x\\nZKzp00awqnJLM4jDnVXw4FijtN6bsJeSPVRRZwAgP0vcb51gO/CRkG0gzMUCJvWI\\ncM4f0nP9EQKBgQDPkMTzdjxt5ixErxzp7DGcAx3NG4UHaFCYAwrXOdr0LyWpaHek\\n3PiMxv61CBKhzcrW7V6BCgZ7PPWx1rDB2pnvtx6wYdtk5nO8Aazbk9Y9yBgZCjht\\nqjpt3V9NHLWvsyPwfy6AdE2JTE29kvLyaU83HBhMe4l2flsNu6MxOXpOaQKBgQCa\\nQiPG0NA7cyj4Ts6qIYlh5zhqzlep9ArOzZs9U1p6ahXp2I86aKBBKxACZcy8j6Cb\\n7gyWhc40PIi6iH/brqHUXWuO1lF/6ADoI6s9ALd1yRaNLn8FEofK6C21UKZm6AJc\\nk+XlOBDwn1giii0x7jo+UF1XfHsIHp0WGDgOT6Xn4QKBgQDetLe431FFDbYmsdAd\\nSov8Dy8loxRhkeGUxf7qWrf3cI4/fKqmT29L0NjayEglQTd3V6aF2OhjX/gOo1Vf\\nQcQvolD1efN+D66rRpwSPSzQ2oDPXwWyCdJr7I24zjjvbfG/pCkrdqAk1zwUxx81\\nAHo1qvXT+fDb1ZM2U90PPieptQ==\\n-----END PRIVATE KEY-----\\n\", \"client_email\": \"zhenkun@zhenkun-957.iam.gserviceaccount.com\", \"client_id\": \"103111512865080355330\", \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\", \"token_uri\": \"https://accounts.google.com/o/oauth2/token\", \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\", \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/zhenkun%40zhenkun-957.iam.gserviceaccount.com\" } 由這個取出這六個參數(surface/auth/activate_service_account.py) \"client_id\": \"103111512865080355330\", \"client_email\": \"zhenkun@zhenkun-957.iam.gserviceaccount.com\", \"private_key_id\": \"d19f1f372bdb4493f05fd8d636aa3218f0b9c2a1\", \"private_key\": \"-----BEGIN PRIVATE KEY-----\\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDDTnzisZPMhds6\\nYUvlyuIUXmB84/zONIkvKLIGhkDXpkmWF6xDGV76RBSMTPu3PGJBwB1hFE2Xetqa\\nnTo0nDFetZe6oVb8g6Yr1aHtSTAYIdtrQIwSXDZaX+6eiY7tA8hy2oXZERWoVbio\\nTVnI4Ga+5hcqeGGRj31IXmm6z1254o3uOBq6+6Q3GmghjTPcVJyxRdpztWbivJuY\\n9CWOqAKZTFTSJ4qPTb7V4smUdYkdWPXdfbKLFs3fy8rES4C7lQNQ57LS36MnxcPm\\niQuuRzDvGdLkOVosTJ3qLDMDGmR8WPau6SGNURNFyNPRjCcTkrntgNbT8y/QqPCE\\ni0P6KenLAgMBAAECggEAZdR0dNXVk9tu1F+KbQN9INWcRUGxu+nUZQw41gIFqOqA\\nj4tEO6/sv1vjwssYqw8Gw/Vg3A7z7bkWZWr4wBl3/EN+GsaoTfxuFYjLZqa0NsDg\\nYGlFHwWJKVG/XlWmeZlxV8Dr7KNlwWEAaG/8Eio+J+Zbyb7+UCCaV7MyOT6JRbMa\\nyiEVTX7JZ/l1c7AhrJ5s8UaZtcxSNNlhV4hC+zJ8DU4eq3bu+66xvit0io6Ymmog\\nDT7chh2SP25b95TUSnZfAxWvvC532viDonyYwYZ9CWt+aBNkWGTuIFZYd6IeC4vH\\nKbLH7f3qbLVFrFQZKQb0urCumWkHFS7ndFYY6TdaQQKBgQDkCwF6L4zMShB96WG7\\nVv8XUJptqd54QVWtlVdeYgdN7TGYescDifQyd33ufDahiTrHv0W0ih4QQQeZd77f\\np/QYuVHdFhMm9UYZq2iVAYBTE9FhomG1rn7BfzTvJI8VEQcAlHMDHn7qtGDtuI5v\\nHjyZPW92ewnp450bEMZ/L/6pGwKBgQDbQBHQ4N7bO07j32SvIazlO1z2O5jeaLxt\\nLPiQyWxfYq6Y2PnPNW+BCM/Zvv45sqJ4NANyBE/1k9qCE+OkRgeLic9Sbz2VWC4x\\nZKzp00awqnJLM4jDnVXw4FijtN6bsJeSPVRRZwAgP0vcb51gO/CRkG0gzMUCJvWI\\ncM4f0nP9EQKBgQDPkMTzdjxt5ixErxzp7DGcAx3NG4UHaFCYAwrXOdr0LyWpaHek\\n3PiMxv61CBKhzcrW7V6BCgZ7PPWx1rDB2pnvtx6wYdtk5nO8Aazbk9Y9yBgZCjht\\nqjpt3V9NHLWvsyPwfy6AdE2JTE29kvLyaU83HBhMe4l2flsNu6MxOXpOaQKBgQCa\\nQiPG0NA7cyj4Ts6qIYlh5zhqzlep9ArOzZs9U1p6ahXp2I86aKBBKxACZcy8j6Cb\\n7gyWhc40PIi6iH/brqHUXWuO1lF/6ADoI6s9ALd1yRaNLn8FEofK6C21UKZm6AJc\\nk+XlOBDwn1giii0x7jo+UF1XfHsIHp0WGDgOT6Xn4QKBgQDetLe431FFDbYmsdAd\\nSov8Dy8loxRhkeGUxf7qWrf3cI4/fKqmT29L0NjayEglQTd3V6aF2OhjX/gOo1Vf\\nQcQvolD1efN+D66rRpwSPSzQ2oDPXwWyCdJr7I24zjjvbfG/pCkrdqAk1zwUxx81\\nAHo1qvXT+fDb1ZM2U90PPieptQ==\\n-----END PRIVATE KEY-----\\n\" \"scopes\" : \"\"('https://www.googleapis.com/auth/userinfo.email', 'https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/appengine.admin', 'https://www.googleapis.com/auth/compute')\"\" \"\"user_agent\":\"\"google-cloud-sdk\" 建立出(surface/auth/activate_service_account.py) { \"service_account_name\": \"zhenkun@zhenkun-957.iam.gserviceaccount.com\", \"_service_account_id\": \"103111512865080355330\", \"id_token\": null, \"_token_uri\": \"https://accounts.google.com/o/oauth2/token\", \"token_uri\": \"https://accounts.google.com/o/oauth2/token\", \"_private_key_id\": \"d19f1f372bdb4493f05fd8d636aa3218f0b9c2a1\", \"token_response\": null, \"client_id\": null, \"token_expiry\": null, \"_class\": \"ServiceAccountCredentials\", \"refresh_token\": null, \"_module\": \"googlecloudsdk.core.credentials.service_account\", \"_private_key_pkcs8_text\": \"-----BEGIN PRIVATE KEY-----\\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDDTnzisZPMhds6\\nYUvlyuIUXmB84/zONIkvKLIGhkDXpkmWF6xDGV76RBSMTPu3PGJBwB1hFE2Xetqa\\nnTo0nDFetZe6oVb8g6Yr1aHtSTAYIdtrQIwSXDZaX+6eiY7tA8hy2oXZERWoVbio\\nTVnI4Ga+5hcqeGGRj31IXmm6z1254o3uOBq6+6Q3GmghjTPcVJyxRdpztWbivJuY\\n9CWOqAKZTFTSJ4qPTb7V4smUdYkdWPXdfbKLFs3fy8rES4C7lQNQ57LS36MnxcPm\\niQuuRzDvGdLkOVosTJ3qLDMDGmR8WPau6SGNURNFyNPRjCcTkrntgNbT8y/QqPCE\\ni0P6KenLAgMBAAECggEAZdR0dNXVk9tu1F+KbQN9INWcRUGxu+nUZQw41gIFqOqA\\nj4tEO6/sv1vjwssYqw8Gw/Vg3A7z7bkWZWr4wBl3/EN+GsaoTfxuFYjLZqa0NsDg\\nYGlFHwWJKVG/XlWmeZlxV8Dr7KNlwWEAaG/8Eio+J+Zbyb7+UCCaV7MyOT6JRbMa\\nyiEVTX7JZ/l1c7AhrJ5s8UaZtcxSNNlhV4hC+zJ8DU4eq3bu+66xvit0io6Ymmog\\nDT7chh2SP25b95TUSnZfAxWvvC532viDonyYwYZ9CWt+aBNkWGTuIFZYd6IeC4vH\\nKbLH7f3qbLVFrFQZKQb0urCumWkHFS7ndFYY6TdaQQKBgQDkCwF6L4zMShB96WG7\\nVv8XUJptqd54QVWtlVdeYgdN7TGYescDifQyd33ufDahiTrHv0W0ih4QQQeZd77f\\np/QYuVHdFhMm9UYZq2iVAYBTE9FhomG1rn7BfzTvJI8VEQcAlHMDHn7qtGDtuI5v\\nHjyZPW92ewnp450bEMZ/L/6pGwKBgQDbQBHQ4N7bO07j32SvIazlO1z2O5jeaLxt\\nLPiQyWxfYq6Y2PnPNW+BCM/Zvv45sqJ4NANyBE/1k9qCE+OkRgeLic9Sbz2VWC4x\\nZKzp00awqnJLM4jDnVXw4FijtN6bsJeSPVRRZwAgP0vcb51gO/CRkG0gzMUCJvWI\\ncM4f0nP9EQKBgQDPkMTzdjxt5ixErxzp7DGcAx3NG4UHaFCYAwrXOdr0LyWpaHek\\n3PiMxv61CBKhzcrW7V6BCgZ7PPWx1rDB2pnvtx6wYdtk5nO8Aazbk9Y9yBgZCjht\\nqjpt3V9NHLWvsyPwfy6AdE2JTE29kvLyaU83HBhMe4l2flsNu6MxOXpOaQKBgQCa\\nQiPG0NA7cyj4Ts6qIYlh5zhqzlep9ArOzZs9U1p6ahXp2I86aKBBKxACZcy8j6Cb\\n7gyWhc40PIi6iH/brqHUXWuO1lF/6ADoI6s9ALd1yRaNLn8FEofK6C21UKZm6AJc\\nk+XlOBDwn1giii0x7jo+UF1XfHsIHp0WGDgOT6Xn4QKBgQDetLe431FFDbYmsdAd\\nSov8Dy8loxRhkeGUxf7qWrf3cI4/fKqmT29L0NjayEglQTd3V6aF2OhjX/gOo1Vf\\nQcQvolD1efN+D66rRpwSPSzQ2oDPXwWyCdJr7I24zjjvbfG/pCkrdqAk1zwUxx81\\nAHo1qvXT+fDb1ZM2U90PPieptQ==\\n-----END PRIVATE KEY-----\\n\", \"access_token\": null, \"_kwargs\": { }, \"_user_agent\": \"google-cloud-sdk\", \"invalid\": false, \"_service_account_email\": \"zhenkun@zhenkun-957.iam.gserviceaccount.com\", \"_revoke_uri\": \"https://accounts.google.com/o/oauth2/revoke\", \"assertion_type\": null, \"_scopes\": \"https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/appengine.admin https://www.googleapis.com/auth/compute\", \"client_secret\": null, \"revoke_uri\": \"https://accounts.google.com/o/oauth2/revoke\", \"user_agent\": \"google-cloud-sdk\" } 取得access token(third_party/oauth2client/service_account.py) $ gcloud auth print-access-token access_token { 'alg': 'RS256', 'typ': 'JWT', 'kid': 'd19f1f372bdb4493f05fd8d636aa3218f0b9c2a1' } { 'iss': 'zhenkun@zhenkun-957.iam.gserviceaccount.com', 'scope': 'https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/appengine.admin https://www.googleapis.com/auth/compute', 'aud': 'https://accounts.google.com/o/oauth2/token', 'exp': 1471940749, 'iat': 1471937149 } © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/9-GoogleCloud/2-Map/1-Distance_Matrix.html":{"url":"md/9-GoogleCloud/2-Map/1-Distance_Matrix.html","title":"Distance Matrix","keywords":"","body":"Distance Matrix tagsstart Google Cloud Map API Distance Matrix tagsstop 計價 標準使用者 每天可以有 2,500 個免費元素。 每個查詢可以有 100 個元素。 每 10 秒可以有 100 個元素。 每 1000 個額外元素為 $0.50 美元，每天最多可以有 100,000 個元素。 進階使用者 每日配額每 24 小時可有 100,000 個元素以上，視年度合約購買量而定。 每個查詢可以有 625 個元素。 每 10 秒可以有 1,000 個元素。 多點距離 & 時間 URL：https://maps.googleapis.com/maps/api/distancematrix/output?input=value Python：API - Client.distance_matrix Python：Source Code - distance_matrix.py 起點與目的地矩陣的旅行距離與時間。 Key Input Option Input Output Type Output Rows Element keykey modemode xmlxml statusTop status elementelement statusElement status originsorigins languagelanguage jsonjson origin_addressesorigin_addresses durationduration destinationsdestinations avoidavoid destination_addressesdestination_addresses duration_in_trafficduration_in_traffic unitsunits rowsrows distancedistance arrival_timearrival_time farefare departure_timedeparture_time traffic_modeltraffic_model transit_modetransit_mode transit_routing_preferencetransit_routing_preference Python Library def distance_matrix(client, origins, destinations,mode=None, language=None, avoid=None, units=None,departure_time=None, arrival_time=None,transit_mode=None,transit_routing_preference=None, traffic_model=None) Sample code import googlemaps client = googlemaps.Client(key='AIzaSyAz1hWEiamCgwsceUYG_dQkvTmfwTBoFT4') origins = ['Vancouver BC','Seattle'] destinations = ['San Francisco','Victoria BC'] directions_result = client.distance_matrix(origins,destinations) for i in directions_result.get('rows'): print i print '------------------------------' Output { \"destination_addresses\" : [ \"美國加利福尼亞州舊金山\", \"加拿大英屬哥倫比亞維多利亞\" ], \"origin_addresses\" : [ \"加拿大英屬哥倫比亞溫哥華\", \"美國華盛頓西雅圖\" ], \"rows\" : [ { \"elements\" : [ { \"distance\" : { \"text\" : \"1,528 公里\", \"value\" : 1528399 }, \"duration\" : { \"text\" : \"15 小時 6 分\", \"value\" : 54365 }, \"status\" : \"OK\" }, { \"distance\" : { \"text\" : \"114 公里\", \"value\" : 114161 }, \"duration\" : { \"text\" : \"3 小時 10 分\", \"value\" : 11403 }, \"status\" : \"OK\" } ] }, { \"elements\" : [ { \"distance\" : { \"text\" : \"1,300 公里\", \"value\" : 1299971 }, \"duration\" : { \"text\" : \"12 小時 36 分\", \"value\" : 45340 }, \"status\" : \"OK\" }, { \"distance\" : { \"text\" : \"172 公里\", \"value\" : 171688 }, \"duration\" : { \"text\" : \"4 小時 35 分\", \"value\" : 16479 }, \"status\" : \"OK\" } ] } ], \"status\" : \"OK\" } key:Key：您應用程式的API 金鑰。 language:Language：語言設定，請參閱支援的語言清單。 arrival_time:arrival_time：針對大眾運輸要求指定抵達時間(秒)，自 1970 年 1 月 1 日午夜 (UTC) 起算，不可與departure_time並存。 departure_time:departure_time：出發時間(秒)，自 1970 年 1 月 1 日午夜 (UTC) 起算，值可以是now。如果mode=driving時，設定此值才會回傳duration_in_traffic。 transit_mode:transit_mode：選擇大眾運輸方式，只有當mode為 transit 時，才能為要求指定此參數。(bus|subway|train|tram|rail(=train+tram+subway)) transit_routing_preference:transit_routing_preference：選擇大眾運輸的偏好，只有當mode為 transit 時，才能為要求指定此參數。(less_walking|fewer_transfers) © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/9-GoogleCloud/2-Map/2-Places.html":{"url":"md/9-GoogleCloud/2-Map/2-Places.html","title":"Places","keywords":"","body":"Places tagsstart Google Cloud Map API Places tagsstop 計價 每 24 小時期間 1 000 個要求 每 24 小時期間 150 000 個要求 「文字搜尋」服務會乘上 10 倍 places.py 地點資料 附近地點搜尋 URL:https://maps.googleapis.com/maps/api/place/nearbysearch/output?input=value Python:Client.places_nearby 搜尋指定區域內的地點。 Key Input Option Input Output Type Output Result keykey keywordkeyword xmlxml statusstatus name locationlocation languagelanguage jsonjson html_attributions vicinity radiusradius minpriceminprice next_page_token type maxpricemaxprice result geometry namename rating opennowopennow icon rankbyrankby reference typestypes id pagetokenpagetoken opening_hours zagatselectedzagatselected photo place_id scope Python Library def places_nearby(client, location, radius=None, keyword=None, language=None,min_price=None, max_price=None, name=None, open_now=False,rank_by=None, type=None, page_token=None) 到 Sample code import googlemaps client = googlemaps.Client(key='AIzaSyAz1hWEiamCgwsceUYG_dQkvTmfwTBoFT4') languages = 'zh-TW' location = (25.1207, 121.5019) types = 'gas_station' radius = 500 directions_result = client.places_nearby(location, radius ,language=languages, type=types) for i in directions_result.get('results'): print 'rating:',i.get('rating') print 'name:',i.get('name') print 'scope:',i.get('scope') print 'types:',i.get('types') print 'vicinity:',i.get('vicinity') print '-------------------------------------' 文字搜尋 URL:https://maps.googleapis.com/maps/api/place/textsearch/output?input=value Python:Client.places 搜尋指定區域內的地點。 Key Input Option Input Output Type Output Result keykey location location xmlxml statusstatus name queryquery languagelanguage jsonjson html_attributions type minpriceminprice next_page_token formatted_address maxpricemaxprice result geometry radius radius rating opennowopennow icon typestypes reference pagetokenpagetoken id zagatselectedzagatselected opening_hours photo price_level place_id Python Library def places(client, query, location=None, radius=None, language=None,min_price=None, max_price=None, open_now=False, type=None,page_token=None) Sample code import googlemaps client = googlemaps.Client(key='AIzaSyAz1hWEiamCgwsceUYG_dQkvTmfwTBoFT4') languages = 'zh-TW' location = (25.1203050, 121.5017983) types = 'food' radius = 100 query = 'Subway' directions_result = client.places(query,location,radius=radius,type=types) for i in directions_result.get('results'): print 'rating:',i.get('rating') print 'name:',i.get('name') print 'types:',i.get('types') print 'formatted_address:',i.get('formatted_address') print '-------------------------------------' 雷達搜尋 URL:https://maps.googleapis.com/maps/api/place/radarsearch/output?input=value Python:Client.places_radar 可讓您一次搜尋高達 200 個地點，但是與一般從「文字搜尋」或「附近地點搜尋」要求傳回的資訊相比較不詳細。 Key Input Option Input Output Type Output Result keykey keywordkeyword xmlxml statusstatus id locationlocation namename jsonjson html_attributions place_id radiusradius minpriceminprice next_page_token reference maxpricemaxprice result geometry opennowopennow typestypes zagatselectedzagatselected Python Library def places_radar(client, location, radius, keyword=None, min_price=None, max_price=None, name=None, open_now=False, type=None) Sample code import googlemaps client = googlemaps.Client(key='AIzaSyAz1hWEiamCgwsceUYG_dQkvTmfwTBoFT4') location = (25.1203050, 121.5017983) radius = 1000 keyword = 'Subway' types = 'food' directions_result = client.places_radar(location,radius,keyword,type=types) for i in directions_result.get('results'): print 'geometry:',i.get('geometry') print 'id:',i.get('id') print 'place_id:',i.get('place_id') print 'reference:',i.get('reference') print '-------------------------------------' 地點詳細資料 place https://maps.googleapis.com/maps/api/place/details/output?parameters 地點相片 places_photo https://maps.googleapis.com/maps/api/place/photo?parameters 地點自動完成 places_autocomplete https://maps.googleapis.com/maps/api/place/autocomplete/output?parameters 查詢自動完成 places_autocomplete_query https://maps.googleapis.com/maps/api/place/queryautocomplete/output?parameters 新增地點 https://maps.googleapis.com/maps/api/place/add/json?key=YOUR_API_KEY 查詢自刪除地點動完成 https://maps.googleapis.com/maps/api/place/delete/json?key=YOUR_API_KEY key:Key：您應用程式的API 金鑰。 location:Location：用來擷取其周圍地點資訊的緯度/經度。指定 location 參數，就必須一併指定 radius 參數。 radius:Radius：定義要傳回地點結果的距離範圍 (單位為公尺)。允許的最大半徑是50,000 公尺。請注意，如果已指定 rankby=distance就不得包括 radius。 language:Language：語言設定，請參閱支援的語言清單。 name:Name：要與地點的名稱比對的一或多個字詞 (以空格字元分隔)。 minprice:Minprice：有效值的範圍是 0 (最負擔得起) 到 4 (最昂貴)，含 0 和 4。特定值所代表的確切金額將因地區而異。 maxprice:Maxprice：有效值的範圍是 0 (最負擔得起) 到 4 (最昂貴)，含 0 和 4。特定值所代表的確切金額將因地區而異。 rankby:Rankby：指定列出結果的順序。(prominence |distance)。 types:Types：將結果限制在至少與其中一個指定類型相符的地點。類型應該以直立線符號分隔 (type1|type2|etc)。請參閱支援的類型清單。 pagetoken:Pagetoken：傳回上次執行之搜尋的接下來 20 個結果。設定 pagetoken 參數將會使用與先前使用的相同參數來執行搜尋，pagetoken 以外的所有參數都將被忽略。 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"md/10-Android/1-adb.html":{"url":"md/10-Android/1-adb.html","title":"Adb","keywords":"","body":"adb tagsstart Android adb tagsstop 簡介 adb shell adb kill-server sudo adb start-server adb devices adb -s f7990ff shell © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 00:07:24 Linux Basic Shell Makefile GDB Shell Shell Makefile Makefile Markdown Markdown GDB GDB Namespace 簡介 什麼是Network Namespace 範例 Network namespace 什麼是Network Namespace 範例 mininet 什麼是 mininet 什麼是 SDN mininet 實戰 SDN 什麼是 SDN Git Basic GStreamer Basic Voice Basic Video Basic Docker Basic Alljoyn Basic 架構說明 啟動流程 & 程式碼 Allplay Framework Basic 架構說明 啟動流程 & 程式碼 Allplay Gateway 架構說明 啟動流程 & 程式碼 Allplay Allplay cmake Basic Target valgrind Valgrind memory Valgrind Google Cloud Speech Distance Matrix Places Speech Speech API Speech Distance Matrix Places Map Distance Matrix Places Distance Matrix Distance Matrix Places Places Android Adb adb Adb "}}