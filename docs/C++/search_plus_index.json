{"./":{"url":"./","title":"Introduction","keywords":"","body":"READ ME © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 03:40:54 "},"Thread.html":{"url":"Thread.html","title":"Thread","keywords":"","body":"Thread [TOC] std::condition_variable 1 說明 使Thread與Thread之間有著等待與通知的機制 因此最主要會有兩個功能的function:wait&signal 呼叫wait的Thread一般被定位成consumer 呼叫signal的Thread一般被定位成Productor或Worker 2 進階說明 3 範例 #include // std::cout #include // std::thread #include // std::mutex, std::unique_lock #include // std::condition_variable std::mutex mtx; // 全局互斥锁. std::condition_variable cv; // 全局条件变量. bool ready = false; // 全局标志位. void do_print_id(int id) { std::unique_lock lck(mtx); while (!ready) // 如果标志位不为 true, 则等待... cv.wait(mtx); // 当前线程被阻塞, 当全局标志位变为 true 之后, // 线程被唤醒, 继续往下执行打印线程编号id. std::cout lck(mtx); ready = true; // 设置全局标志位为 true. cv.notify_all(); // 唤醒所有线程. } int main() { std::thread threads[10]; // spawn 10 threads: for (int i = 0; i note std::condition_variable wait wait_for wait_until notify_one notify_all mutex std::mutex timed_mutex recursive_mutex recursive_timed_mutex lock unlock lock std::unique_lock std::lock_guard std::lock thread std::thread 如果不使用调用t.join()就会遇到 “terminate called whithout an active exception”,但是在使用boost:thread的时候却没遇到这个问题，google了一下，找到答案: 大意是说，在~thread();前没有调用join()则会遇到问题很难调试，如果不想调用join()等线程结束的话你可以调用detach().这样就不会遇到”terminate called whithout an active exception” 如下: { std::thread t(func); t.detach(); } std::this_thread get_id()可以用來取得目前的執行序的 id（型別是 thread::id）也可以透過 std::thread 的物件的 get_id() 這個 member function 來取得（例如：mThread.get_id()）。這個功能主要是可以用來識別不同的執行序，有的時候是用的到的。 yield() CPU還是吃滿滿 是暫時放棄一段 CPU 時間、讓給其他執行序使用的；這個應該算是比較進階的使用了，在這邊暫時跳過，之後有機會再整理。 sleep_for() CPU不會吃到 和 sleep_until() 則是用來讓目前的執行序暫時停下來的，前者是停止一段指定的時間、後者則是設定一個絕對時間、讓執行序在指定的時間再繼續執行；而時間的參數，則是要使用 std::chrono（MSDN）的 duration（範例）和 time_point（範例）這兩種型別的時間資料。 future std::future async get valid wait wait_for wait_until future_status::ready 共享状态的标志已经变为 ready，即 Provider 在共享状态上设置了值或者异常。 future_status::timeout 超时，即在规定的时间内共享状态的标志没有变为 ready。 future_status::deferred 共享状态包含一个 deferred 函数 std::chrono::milliseconds std::chrono::seconds atomic std::atomic std::atomic_flag test_and_set() 函数检查 std::atomic_flag 标志，如果 std::atomic_flag 之前没有被设置过，则设置 std::atomic_flag 的标志，并返回先前该 std::atomic_flag 对象是否被设置过，如果之前 std::atomic_flag 对象已被设置，则返回 true，否则返回 false。 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 03:40:54 "},"md/1-Basic/Basic.html":{"url":"md/1-Basic/Basic.html","title":"Basic","keywords":"","body":"Basic [TOC] non-trivial designated initializers not supported This does not work with g++. You are essentially using C constructs with C++. Couple of ways to get around it. 1) Remove the “.” and change “=” to “:” when initializing. 關件詞 POD Trivial Copyable Standard ( !delete ) @import \"1.csv\" direct (explicit) initial Data d{15} Data d = Data{15} Data d() copy initial Data d = 15 Data d = {15} Dlopen libA.so + libB.so -> libC.so different static in A static in B same static in C static in C’s class static in C’s class function Unique static in C’s class inline function load A: c.printInline() load B: c.printInline() unload B：成功 unload A：要看有沒有2被A抓住,有則是不成功，沒有則成功 lib https://gcc.gnu.org/onlinedocs/gcc-5.2.0/gcc/Link-Options.html#Link-Options 這句話翻譯過來的意思就是說，如果你的庫在連結時安排的順序是： foo.o -lz bar.o 那麼gcc的連結器先搜索庫foo，然後是z庫，然後是bar庫。 這樣就帶來一個問題，如果庫bar調用了庫z裡面的函數，但是連結器是先搜索的庫z，這時候並沒有發現庫bar調用庫z啊，所以就不會把庫z中的這部分函數體挑出來進行連結。 而是只把庫z中，被foo庫調用的函數體挑出來。 越是被別人調用的越底層的庫，就越放在後面 越是調用別人的越上層的庫，就越放在前面。 lc libc Linux 下的 ANSI C 函数库 包含了 C 语言最基本的库函数 stdio.h glibc Linux 下的 GUN C 函数库 libc.so libc.a lgcc libgcc gcc soft float 部分整形/浮點運算 異常處理 雜項函數 libgcc.a libgcc.so lstdc++ gcc for C++ libstdc++.so lc++ clang libc++.so glib GNOME gobjetct lm math 一般link順序 lm -lgcc -lc © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 03:40:54 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2024-10-14 03:40:54 "}}