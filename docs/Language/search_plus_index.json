{"./":{"url":"./","title":"Introduction","keywords":"","body":"READ ME © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2018-07-25 13:55:33 "},"md/1-Swift/1-Basic.html":{"url":"md/1-Swift/1-Basic.html","title":"Basic","keywords":"","body":"Basic tagsstart Swift Language tagsstop 變數 一般變數 var age:Int = 18 var height:Float = 173.5 var weight = 65.1 //不一定需要宣告型態,但最好宣告 let name:String = \"坤\" //final var boolTrue:Bool = true var boolFalse:Bool = false print(\"年紀\\(age)歲,身高\\(height)公分,\"+\"體重\\(weight)公斤\") print(\"boolTrue＝\\(boolTrue),boolFalse=\\(boolFalse)\") 年紀20歲,身高160.0公分,體重50.0公斤 boolTrue＝true,boolFalse=false Byte let minIntU8:UInt8 = UInt8.min //byte let maxIntU8:UInt8 = UInt8.max //byte print(\"最小值＝\\(minIntU8)歲,最大值=\\(maxIntU8)\") 最小值＝0歲,最大值=255 強制轉型 var dValue:Double = 100.999 var fValue:Float = Float(dValue) //必須強制轉型 var iValue:Int = Int(fValue) print(\"Double＝\\(dValue),Float=\\(fValue),Int=\\(iValue)\") Double＝100.999,Float=100.999,Int=100 空變數 var number:Int? //未定義內容的空間,直接印出會變成nil //效果等同宣告指標卻還沒分配空間 number = 100 print(\"number＝\\(number)\") number＝Optional(100) assert assert(boolFalse, \"發生錯誤\") //斷程式專用,防惡意軟體 不常拿來debug 集合 同型態集合-[] var apple:[String] = [\"iPad\",\"iPhone\"] let newProduct:[String] = [\"ipod\",\"Mac\"] print(\"Apple目前產品有\\(apple[0])與\\(apple[1])\") apple += newProduct apple.append(\"iWatch\") apple += [\"Mac Book Pro\"] apple.insert( \"magic mouse\", at: 2 ) //特定格式 let r_1 = apple.remove(at: 2) let r_2 = apple.removeLast() for (index,product) in apple.enumerated() { //陣列 列舉法 print(\"目前第\\(index)項產品是\\(product)\") } apple.removeAll(keepingCapacity: true) if apple.isEmpty { print(\"clean\") } var htc:[String] = [String]() htc.append(\"one\") htc += [String](repeating: \"尚未推出\", count: 3) for (index,product) in htc.enumerated() { print(\"目前第\\(index)項產品是\\(product)\") } Apple目前產品有iPad與iPhone 目前第0項產品是iPad 目前第1項產品是iPhone 目前第2項產品是ipod 目前第3項產品是Mac 目前第4項產品是iWatch clean 目前第0項產品是one 目前第1項產品是尚未推出 目前第2項產品是尚未推出 目前第3項產品是尚未推出 異型態集合-() var product = (\"iPad wifi\",19999) var (device,price) = product //集合與命名 var (device_2,_) = product //集合與命名 print(\"\\(product.0)售價,\\(product.1)元\") print(\"\\(device)售價,\\(price)元\") print(\"\\(device_2)售價\") var product_2 = (device:\"iPad wifi\",price:19999,capacity:500) print(\"\\(product_2.0)售價,\\(product_2.1)元,\\(product_2.2)G\") print(\"\\(product_2.device)售價,\\(product_2.price)元,\\(product_2.capacity)G\") iPad wifi售價,19999元 iPad wifi售價,19999元 iPad wifi售價 iPad wifi售價,19999元,500G iPad wifi售價,19999元,500G Array var sony:Array = Array(repeating: \"即將推出\", count: 4) //Array集合 字串版型 sony[0 ... 2 ] = [\"z1\",\"z2\",\"z3\"] //加入元素 for (index,product) in sony.enumerated() { print(\"目前第\\(index)項產品是\\(product)\") } 目前第0項產品是z1 目前第1項產品是z2 目前第2項產品是z3 目前第3項產品是即將推出 NSArray var acer:NSArray = NSArray(objects: \"a_1\",\"a_2\",88) //槓Object C的Array,此宣告為final值,也就是內容不能替換 for (index,product) in acer.enumerated() { print(\"目前第\\(index)項產品是\\(product)\") } 目前第0項產品是a_1 目前第1項產品是a_2 目前第2項產品是88 NSMutableArray var mi:NSMutableArray = NSMutableArray() mi.add(\"紅米機\") print(\"\\(mi.object(at: 0))\") var ary = [[4,7,6,9],[1,2,3],[4,5,6,7,8]] for i:Int in 0 .. 紅米機 4 7 6 9 1 2 3 4 5 6 7 8 4 7 6 9 1 2 3 4 5 6 7 8 Dictionary var apple:Dictionary = [\"iPhone\":26000,\"iPad\":18000] apple[\"iWatch\"] = 16800 for element in apple.keys{ print(\"商品\\(element) = \\(apple[element])\") } var max:Int = 0 for element in apple.values{ if max = [ \"賀振坤\" : [\"吳國隆\",\"王大維\"] , \"王勇傑\" : [\"賀振坤\",\"王大維\"] ] var temp:[String] = people[\"賀振坤\"]! people[\"賀振坤\"] = people[\"王勇傑\"] people[\"王勇傑\"] = temp for (person,friends) in people{ print(\"我的名字叫做\\(person)\") for friend in friends { print(\"我的朋友有\\(friend)\\t\", terminator: \"\") } print(\"\") } 商品iPad = Optional(18000) 商品iWatch = Optional(16800) 商品iPhone = Optional(26000) 最貴為26000元 我的名字叫做賀振坤 我的朋友有賀振坤 我的朋友有王大維 我的名字叫做王勇傑 我的朋友有吳國隆 我的朋友有王大維 迴圈 & 邏輯判斷 For each var sum:Int = 0 for i in (0 .. 4 4 Switch var ID:Int = 3 switch ID { case 1: print(\"1\") //case 若進入不需要加入break case 2: print(\"2\") case 3 ... 10: print(\"3~10\") fallthrough //穿越到下一個case繼續 case 11 ... 20: print(\"11~20\") default: break //default必須存在且有功能,若無功能則加入break } var say:String = \"食べます\" var chinese:String? switch say { case \"Eat\",\"食べます\": chinese = \"吃飯\" case \"Hello\",\"こんにちは\": chinese = \"問安\" default: break } if chinese == nil { print(\"?\") } else { print(\"\\(chinese)\") } 3~10 11~20 Optional(\"吃飯\") Function Function & Function variable func toAdd( _ num1:Int , num2:Int ) -> Int{ return num1 + num2 } func toSub( _ num1:Int , num2:Int ) -> Int{ return num1 - num2 } func countAddAndSub( _ a:Int , b:Int , fun_add:(Int,Int) -> Int , fun_sub:(Int,Int) -> Int ) -> (Int,Int) { return ( fun_add(a,b) , fun_sub(a,b) ) } var a = 20 , b = 10 //var mathFuncAdd:(Int,Int)->Int = toAdd //var mathFuncSub:(Int,Int)->Int = toSub var result = countAddAndSub( a , b:b , fun_add:toAdd , fun_sub:toSub) //result = countAddAndSub( a , b , mathFuncAdd , mathFuncSub) print(\"add = \\(result.0),sub = \\(result.1)\") add = 30,sub = 10 Function local variable scope func getNewP (_ money:Int) -> () -> Int{ var salary:Int = 0 func workADay() -> Int { salary += money return salary } return workADay } let emp_1 = getNewP(700), emp_2 = getNewP(800) , emp_3 = getNewP(900) //由於emp_1為workADay()的實體,而workADay()實體緊抓著屬於自己的salary,故不得釋放salary的memory for i in 1 ... 2 { print(\"第\\(i)天員工1的薪水 ＝ \\(emp_1()) 元\") print(\"第\\(i)天員工2的薪水 ＝ \\(emp_2()) 元\") print(\"第\\(i)天員工3的薪水 ＝ \\(emp_3()) 元\") } 第1天員工1的薪水 ＝ 700 元 第1天員工2的薪水 ＝ 800 元 第1天員工3的薪水 ＝ 900 元 第2天員工1的薪水 ＝ 1400 元 第2天員工2的薪水 ＝ 1600 元 第2天員工3的薪水 ＝ 1800 元 Named Function & Closure func a() -> Void { print(\"這是Ａ函式\") } func b() -> Void { print(\"這是B函式\") } func countDown ( _ start:Int , timesupClosure:() -> Void ) -> Void{ for i in (0 ... start).reversed() { if( i > 0) { print(\"倒數\\(i)秒\") } else { timesupClosure() } } } countDown(10, timesupClosure:a) countDown(10, timesupClosure:b) countDown(10, timesupClosure:{ print(\"這是Ｃ函式\") //臨時函數如果沒有參數,沒有回傳,不需要多餘的in } ) 倒數3秒 倒數2秒 倒數1秒 這是Ａ函式 倒數3秒 倒數2秒 倒數1秒 這是B函式 倒數3秒 倒數2秒 倒數1秒 這是Ｃ函式 Lambda & Closure func babyName (_ secName:String ,firNameFunc:(String) -> String) -> Void { print(\"寶寶的名字叫\\(firNameFunc(secName))\") } //「臨時函式」的宣告規矩 一切宣告完以後要加「in」 爾後的區塊才是「函式本體」 babyName(\"賀\",firNameFunc: {(secName : String) -> String in return secName + \"振坤\" } ) //「臨時函式」若當「參數」,可寫在「呼叫此臨時函式」的「後方」 babyName(\"賀\") {(secName : String) -> String in return secName + \"振坤\" } //「臨時函式」若當「參數」,此「臨時函式」可「使用呼叫者的參數」 babyName(\"賀\"){return $0 + \"振坤\"} //「臨時函式」若當「參數」,則可直接將return的結果打入{}內,當作呼叫者的參數 // 若此寫法的「臨時函式」回傳不帶參數,會認為此「臨時函式」是不需要輸入參數的函式 babyName(\"賀\"){$0 + \"振坤\"} 寶寶的名字叫賀振坤 寶寶的名字叫賀振坤 寶寶的名字叫賀振坤 寶寶的名字叫賀振坤 Objective-C Bridging Header Project -> Build Settings -> Objective-C Bridging Header Swift_4-Bridging-Header.h void getImput(int *output); file.c #include #include void getImput(int *output){ scanf(\"%i\",output); } main.swift var num:CInt = 0; print(\"請輸入任意整數\") getImput(&num); if Int(num) % 2 == 1 { print(\"奇數\") } else { print(\"偶數\") } 請輸入任意整數 2 偶數 Enum enum Language { case java case swift case objC case actionScript case other } var tool:Language = .java switch tool { case .java: print(\"此為Java\") case .swift: print(\"此為Swift\") case .objC: print(\"此為objC\") case .actionScript: print(\"此為ActionScript\") default: print(\"此語言為其他語言\") } enum Role{ case status(Float,Float,Float) case name (String) } var roleStatus:Role = Role.status(1000, 599, 200) var roleName:Role = Role.name(\"zhenkun\") var role = roleStatus switch role { case .status(var hp,var sp,var mp) : hp -= 200 print(\"Hp:\\(hp) Sp:\\(sp) Mp:\\(mp)\") case let .name(username): print(\"\\(username)\") } enum Classroom : Int { case mary = 3 , ada , fred = 6 , eva , cathy , diana } if let value = Classroom(rawValue: 7){ print(\"\\(value)\") print(\"\\(value.rawValue)\") } 此為Java Hp:800.0 Sp:599.0 Mp:200.0 eva 7 struct struct Ball { var x:Int = 0 var y:Int = 0 var z:Int = 0 var name:String = \"\" } var b1:Ball = Ball() var b2:Ball = Ball(x: 1, y: 2, z: 3, name: \"blueBall\") b1 = b2 b1.x = 100 print(\"\\(b2.x)\") struct Point { var X:Float = 0.0 var Y:Float = 0.0 } struct Size { var w:Float = 0.0 var l:Float = 0.0 } struct Rect { var origin:Point = Point() var size:Size = Size() var center:Point{ //Swift的struct有能力將「屬性」與「屬性」之間建立關係 利用「get」&「set」 get { let centerX = origin.X + (size.w/2) let centerY = origin.Y + (size.l/2) return Point(X:centerX ,Y:centerY) } set (newCenter) { self.origin.X = newCenter.X - (size.w/2) self.origin.Y = newCenter.Y - (size.l/2) } } var area:Float{ //只有get沒有set return size.w * size.l } } var rect:Rect = Rect(origin: Point(X: 20, Y: 30), size: Size(w: 50, l: 50)) //測試get rect.center = Point(X: 60, Y: 60) //測試set rect.center.X = 70 //set進階版 此行等於rect.center = Point(X: 70, Y: 不變) //rect.area = 0.0 //get only的屬性沒有辦法set print(\"原點：(\\(rect.origin.X),\\(rect.origin.Y))\\n範圍：(\\(rect.size.w),\\(rect.size.l))\\n中心：(\\(rect.center.X),\\(rect.center.Y))\\n面積：\\(rect.area)\") struct ScoreRecord{ var scroe:Int = 2{ //若「屬性」與其他「屬性」沒有關聯,則有個多餘的方式,willSet＆didSet 幾乎沒用 且didSet中有特定的關鍵字:oldValue willSet(newScore){ print(\"傳入新分數\\(newScore)\") } didSet { print(scroe >= oldValue ? \"進步了\\(scroe - oldValue)分\" : \"退步了\\(oldValue - scroe)分\") //didSet屬性設定中的特定關鍵字:oldValue } } } var score:ScoreRecord = ScoreRecord() score.scroe = 10 struct RoleStruct { var name:String? init(){ name = \"坤\" print(\"初始\") } } var roleA:RoleStruct = RoleStruct() print(\"\\(roleA.name)\") 1 原點：(45.0,35.0) 範圍：(50.0,50.0) 中心：(70.0,60.0) 面積：2500.0 傳入新分數10 進步了8分 初始 Optional(\"坤\") Class 建構&解構&Lazy struct Position { var X:Float = 0.0 var Y:Float = 0.0 var Z:Float = 0.0 } class Cube { var m_pos:Position = Position() var m_l:Float var m_w:Float var m_h:Float init (p:Position , l:Float , w:Float , h:Float){ m_pos = p m_l = l m_w = w m_h = h } } var cubeA:Cube = Cube(p: Position(), l: 200.0 , w: 300.0 , h: 1000.0) //var cubeB:Cube = Cube() //error 建構子被覆蓋 print(\"體積：\\(cubeA.m_l * cubeA.m_w * cubeA.m_h)\") class DataImporter{ var path:String = \"path.txt\" } class DataManager{ lazy var dataImp:DataImporter = DataImporter() //lazy:物件尚不用到時,不建立實體 var data:[String] = [String]() } let dataManager:DataManager = DataManager() dataManager.data.append(\"Data_1\") dataManager.data.append(\"Data_2\") print(\"將資料存到\\(dataManager.dataImp.path)裡面\") class Role{ var _name:String? var _hp:Int? var _mp:Int? init(){ _name = \"\" _hp = 0 _mp = 0 } init(name:String){ _name = name _hp = 0 _mp = 0 } init(name:String,hp:Int,mp:Int){ _name = name _hp = hp _mp = mp } deinit{ print(\"釋放\") } } var role:Role? = Role(name: \"zhenkun\", hp: 1, mp: 1) role = nil 體積：6e+07 將資料存到path.txt裡面 釋放 Private & Static private var acount:Int = 0 struct Classroom{ static var count:Int = 0 } class Student { var _name:String? //物件的靜態屬性：為了安全起見,限定不行使用static直接呼叫來使用或修改 規定要設定get & set,指向此檔案內的private成員做為共同存取 class var number:Int{ get{ return acount } set (newValue){ acount = newValue } } init(name:String){ _name = name print(\"\\(_name)走進教室\") Student.number += 1 //原始寫法,但也沒有特別屬於此物件所有 Classroom.count += 1 //較好的寫法,將所有靜態屬性放入struct 並在使用的時候呼叫就好 } deinit{ print(\"\\(_name)離開教室\") Student.number -= 1 Classroom.count -= 1 } } var s1:Student? = Student(name: \"Zhenkun\") var s2:Student? = Student(name: \"Alex\") print(\"教室\\(Classroom.count)人\") print(\"教室\\(Student.number)人\") s1 = nil s2 = nil print(\"教室\\(Classroom.count)人\") print(\"教室\\(Student.number)人\") Optional(\"Zhenkun\")走進教室 Optional(\"Alex\")走進教室 教室2人 教室2人 Optional(\"Zhenkun\")離開教室 Optional(\"Alex\")離開教室 教室0人 教室0人 繼承 class BaseObject { var l:Float = 0 , w:Float = 0 func getSize (_: Void) ->Float{ return l * w } } class Rect:BaseObject { } class Circle:BaseObject { var r:Float = 0.0 override func getSize (_: Void) ->Float{ return Float (pow( Double(r) , 2.0 ) * M_PI) } } class Cube:BaseObject { var h:Float = 0.0 override func getSize (_: Void) ->Float{ return super.getSize() * h } } var rect:Rect = Rect() var circle:Circle = Circle() var cube:Cube = Cube() rect.l = 10 rect.w = 20 print(\"\\(rect.getSize())\") circle.r = 10 print(\"\\(circle.getSize())\") cube.l = 10 cube.w = 20 cube.h = 30 print(\"\\(cube.getSize())\") 200.0 314.159 6000.0 Protocol 實作 protocol Rect { func getPerimeter(_ w:Int ,l:Int) -> Int func getArea(_ w:Int , l:Int) -> Int } protocol Circle { func getPerimeter(_ r:Float) -> Float func getArea(_ r:Float) -> Float } class Object: Rect,Circle{ //不能多重繼承,但是可以多重實作.若要繼承,父類別需要寫在冒號後的第一個 func getPerimeter(_ w:Int ,l:Int) -> Int { return (l + w) * 2 } func getArea(_ w:Int ,l:Int) -> Int { return l * w } func getPerimeter(_ r:Float) -> Float { return r * r * Float(M_PI) } func getArea(_ r:Float) -> Float { return 2 * r * Float(M_PI) } } var obj:Object = Object() print(\"圓面積：\\(obj.getArea(3)),圓周長：\\(obj.getPerimeter(3))\") print(\"Rect面積：\\(obj.getArea(3, l: 4)),Rect周長：\\(obj.getPerimeter(3,l: 4))\") //參數第一個不需要形容意義(init 例外) 圓面積：18.8496,圓周長：28.2743 Rect面積：12,Rect周長：14 Delegate BankDelegate.swift protocol BankDelegate { func showBroken() -> Void func showBalance(_ money:Int) -> Void } Bank.swift class Bank { var _money:Int = 0 let _bankD:BankDelegate? init (money:Int , bankD:BankDelegate){ _bankD = bankD _money = money } func withDrawal(_ value:Int) -> Void{ if _money >= value { _money -= value _bankD!.showBalance(_money) } else { _bankD!.showBroken() } } func deposit(_ value:Int) -> Void{ _money += value _bankD!.showBalance(_money) } } main.swift class Main:BankDelegate { init(_: Void){ let bank:Bank = Bank(money: 1000, bankD: self) bank.withDrawal(300) bank.deposit(200) bank.withDrawal(1000) } func showBroken() -> Void{ print(\"你已經破產了\") } func showBalance(_ money:Int) -> Void{ print(\"你還剩下\\(money)元\") } } var main:Main = Main() 你還剩下700元 你還剩下900元 你已經破產了 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2018-07-25 13:55:33 "},"md/1-Swift/2-iOS.html":{"url":"md/1-Swift/2-iOS.html","title":"I OS","keywords":"","body":"iOS tagsstart Swift Language iOS Framework tagsstop cocoapods 它是將所有的依賴庫都放到一個名為Pods資料夾中，然後讓專案依賴Pods資料夾，如此，源碼管理工作都從專案移到了Pods資料夾中 Pods資料夾最終會編譯成一個名為libPods.a的文件，專案只需要依賴這個.a檔即可 對於資源文件，CocoaPods提供了一個名為Pods-resources.sh的bash腳本，該腳本在每次專案編譯的時候都會執行，將第三方庫的各種資源文件複製到目標目錄中 CocoaPods通過一個名為Pods.xcconfig檔來在編譯時設置所有的依賴和參數 Setting up CocoaPods master repo 这并不是卡住，而是一直在安装，速度比较慢是正常的，等待就好，如果你想知道进度，那么进行如下操作 新建一个终端窗口 cd ~/.cocoapods/ 再输入du -sh * 隔几分钟查看下下载量在增加就可以了。不要着急，整个文件大概要400M+貌似，急不来的。 Download # Xcode 7 + 8 $ sudo gem install cocoapods --pre # Xcode 7 sudo gem install activesupport -v 4.2.6 sudo gem install cocoapods Podfile # Uncomment the next line to define a global platform for your project # platform :ios, '9.0' target 'listenPro' do # Comment the next line if you're not using Swift and don't want to use dynamic frameworks use_frameworks! # Pods for listenPro pod 'EliteFramework' pod 'Google/Analytics' pod 'FBSDKCoreKit' pod 'FBSDKLoginKit' pod 'FBSDKShareKit' end Install pod install Xcode 7 sudo gem install activesupport -v 4.2.6 sudo gem install cocoapods AppDelegate App生命週期 import UIKit @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { //最重要的兩個元件 //UIApplicationDelegate 內部設定了appa生命週期觸發的函式 var window: UIWindow? //root視窗物件,不包含container //啟動瞬間觸發 func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { return true } //即將終止活動 觸發 func applicationWillResignActive(_ application: UIApplication) { print(\"applicationWillResignActive\"); } //進入後台完成 觸發 func applicationDidEnterBackground(_ application: UIApplication) { print(\"applicationDid Enter Background\"); } //即將進入前端 func applicationWillEnterForeground(_ application: UIApplication) { print(\"application Will Enter Foreground\"); } //app開始活動觸發 func applicationDidBecomeActive(_ application: UIApplication) { print(\"application Did Become Active\"); } //app釋放的瞬間觸發 func applicationWillTerminate(_ application: UIApplication) { print(\"application Will Terminate\"); } } UIWindow var window: UIWindow? //啟動瞬間觸發 func application(_ application: UIApplication,didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { // Initialize window window = UIWindow(frame: UIScreen.main.bounds) // Background color of window window?.backgroundColor = UIColor.white // Set root view controller window?.rootViewController = ViewController() // Show window window?.makeKeyAndVisible() return true } UIView view.removeFromSuperview() view.backgroundColor = UIColor.green self.addSubview(view) view.frame.size = CGSize(width: 100, height: 100) //設置size view.center = CGPoint(x: frame.size.width/2, y: frame.size.height/2) //設置View的「中心點」 self.insertSubview(viewD, aboveSubview: viewC) self.exchangeSubviewAtIndex(2, withSubviewAtIndex: 3) ballView.layer.masksToBounds = true //不去繪製超出遮罩外的範圍 ballView.layer.cornerRadius = w/2 `UIView.beginAnimations(\"MoveGroupAni\", context: nil) UIView.setAnimationDelay(0.1) //從這行到UIView.commitAnimations()之間的繪圖動作,會在0.1秒內逐漸完成,並命名這串動作為MoveGroupAni //若時間還沒到,卻引發了下一個Animations,則動作會立刻完成,以便銜接下一個Animations ballView.center = location UIView.commitAnimations()` self.isUserInteractionEnabled = true //攔截事件,不穿透 Basic Property MainView.swift class MainView: UIView { //CGRect內放著((x,y),(w,h))也就是(原點,寬高) 值為CGFloat,與Float不同的地方只是一個有繪製輸出 override init(frame: CGRect) { super.init(frame: frame) self.backgroundColor = UIColor.brown//透明色UIColor.clearColor let w:CGFloat = 100 let h:CGFloat = 100 //left top var view:UIView = UIView(frame:CGRect(x: 0, y: 0, width: w, height: h) ) view.backgroundColor = UIColor.red self.addSubview(view) //right top view = UIView(frame:CGRect(x: self.frame.size.width - w, y: 0, width: w, height: h) ) view.backgroundColor = UIColor.blue self.addSubview(view) //left button view = UIView(frame:CGRect(x: 0, y: self.frame.size.height - h, width: w, height: h) ) view.backgroundColor = UIColor.green self.addSubview(view) //right button view = UIView(frame:CGRect(x: self.frame.size.width - w, y: self.frame.size.height - h, width: w, height: h) ) view.backgroundColor = UIColor.purple self.addSubview(view) //center view = UIView(frame:CGRect.zero) //空的矩形 view.frame.size = CGSize(width: 100, height: 100) //設置size view.backgroundColor = UIColor.gray view.center = CGPoint(x: frame.size.width/2, y: frame.size.height/2) //設置View的「中心點」 self.addSubview(view) view.removeFromSuperview()//移除需要子物件自己離開 } required init(coder aDecoder: NSCoder) { //初始化失敗時呼叫 fatalError(\"init(coder:) has not been implemented\") } } AppDelegate.swift var mainView: MainView? //啟動瞬間觸發 func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { // Initialize window window = UIWindow(frame: UIScreen.main.bounds) // Background color of window window?.backgroundColor = UIColor.white // Set root view controller window?.rootViewController = ViewController() mainView = MainView(frame: window!.frame) window?.addSubview(mainView!) Subview Layer self.backgroundColor = UIColor.brown//透明色UIColor.clearColor let viewH:CGFloat = 300 //red View let viewA = UIView(frame: CGRect(x: 0, y: 0, width: self.frame.size.width, height: viewH)) viewA.backgroundColor = UIColor.red self.addSubview(viewA) //blue View let viewB = UIView(frame: CGRect(x: 0, y: viewH/2, width: self.frame.size.width, height: viewH)) viewB.backgroundColor = UIColor.blue self.addSubview(viewB) //black View let viewC = UIView(frame: CGRect(x: 0, y: viewH, width: self.frame.size.width, height: viewH)) viewC.backgroundColor = UIColor.black self.insertSubview(viewC, aboveSubview: viewA) //Subview //green View let viewD = UIView(frame: CGRect(x: 0, y: viewH, width: self.frame.size.width, height: viewH/2+100)) viewD.backgroundColor = UIColor.green self.insertSubview(viewD, aboveSubview: viewC) //Subview //self.exchangeSubviewAtIndex(2, withSubviewAtIndex: 3) //交換子view層級 ViewController 每個ViewController有一個view作為這次要控制的主view Touch event touchesBegan touchesMoved touchesEnded let t:UITouch = touch as! UITouch if(t.tapCount == 2) ViewController.swift override func touchesBegan(_ touches: Set, with event: UIEvent?) { for subView in self.view.subviews { subView.touchesBegan(touches, with: event) } } MainView.swift override func touchesBegan(_ touches: Set, with event: UIEvent?) { let touche:UITouch = touches.first! as UITouch //取出touch相對於某View的相對位置 let location:CGPoint = touche.location(in: self) let view = UIView(frame: CGRect(x: location.x, y: location.y, width: 30, height: 30)) view.backgroundColor = UIColor(red: CGFloat(arc4random()%256)/255, green: CGFloat(arc4random()%256)/255, blue: CGFloat(arc4random()%256)/255, alpha: CGFloat(arc4random()%100)/100) //RGB Alpha的value從0-255壓縮到0~1之間的浮點數 self.addSubview(view) ary.append(view) } override func touchesEnded(_ touches: Set, with event: UIEvent?) { } Draw override func draw(_ rect: CGRect) { let drawWidth:CGFloat = 10 m_context = UIGraphicsGetCurrentContext() //畫筆文本 setDrawWidth(drawWidth) //CGContextSet... setContentColer(UIColor.red) //CGCGContextSet... var ori:CGPoint = CGPoint(x: 0, y: 0) let tar:CGPoint = CGPoint(x: frame.size.width, y: frame.size.height) drawLine(ori, tar: tar) //CGContext Set..Move...Add...Path setContentColer(UIColor.blue) //CGCGContextSet... let r:CGFloat = 50 let center:CGPoint = CGPoint(x: frame.size.width - r - drawWidth, y: 0 + r + drawWidth) drawCircle(center, r: r ,isFill: false) //CGContext Set..Move...Add...Path setContentColer(UIColor.green) //CGCGContextSet... let size:CGSize = CGSize(width: 100, height: 100) ori = CGPoint(x: 0 , y: frame.size.height - size.height) drawTriangleRect(ori, rect: size, isFill: true) setContentColer(UIColor.yellow) //CGCGContextSet... let p1:CGPoint = CGPoint(x: 0, y: frame.size.height/2 ) let p2:CGPoint = CGPoint(x: frame.size.width, y: frame.size.height/2 ) let p3:CGPoint = CGPoint(x: frame.size.width/2, y: frame.size.height/4 ) drawQuadCurve(p1, to: p2, curve: p3) } func setContentColer(_ col:UIColor){ //UIColor內含著CGColor,CGColor只是ＡＲＧＢ四個浮點數的集和 let components = col.cgColor.components m_context.setFillColor(red: (components?[0])!, green: (components?[1])!, blue: (components?[2])!, alpha: (components?[3])!) m_context.setStrokeColor(red: (components?[0])!, green: (components?[1])!, blue: (components?[2])!, alpha: (components?[3])!) } func setDrawWidth(_ w:CGFloat){ m_context.setLineWidth(w) //設定畫筆寬度 } func drawLine(_ ori:CGPoint,tar:CGPoint){ m_context.setLineCap(CGLineCap.round) //設定線條樣式,kCG系列是樣式 m_context.move(to: CGPoint(x: ori.x, y: ori.y)) //移動畫筆到某一點 m_context.addLine(to: CGPoint(x: tar.x, y: tar.y))//畫一條線 m_context.strokePath() //空心繪製路徑開始 } func drawCircle(_ center:CGPoint,r:CGFloat,isFill:Bool){ m_context.move(to: CGPoint(x: center.x - r, y: center.y - r)) m_context.addEllipse(in: CGRect(x: center.x - r, y: center.y - r, width: r * 2, height: r * 2)) isFill ? (m_context).fillPath() : m_context.strokePath() } func drawTriangleRect(_ ori:CGPoint, rect:CGSize,isFill:Bool){ m_context.move(to: CGPoint(x: ori.x + (rect.width / 2), y: ori.y)) //移動畫筆到某一點 m_context.addLine(to: CGPoint(x: ori.x, y: ori.y + rect.height)) //畫一條線 m_context.addLine(to: CGPoint(x: ori.x + rect.width, y: ori.y + rect.height)) //畫一條線 m_context.addLine(to: CGPoint(x: ori.x + (rect.width / 2), y: ori.y)) //畫一條線 isFill ? (m_context).fillPath() : m_context.strokePath() } func drawQuadCurve(_ ori:CGPoint, to:CGPoint , curve:CGPoint){ m_context.move(to: CGPoint(x: ori.x, y: ori.y)) //移動畫筆到某一點 m_context.addQuadCurve(to: CGPoint(x: to.x, y: to.y), control: CGPoint(x: curve.x, y: curve.y)) m_context.strokePath() } UINavigationController AppDelegate.swift var window: UIWindow! var navaController:UINavigationController! var mainVC:ViewController! func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { window = UIWindow(frame: UIScreen.main.bounds) mainVC = ViewController() mainVC.refreshWithFrame(window.frame) navaController = UINavigationController() navaController.pushViewController(mainVC, animated: false) //當被掛載時,mainVC裡面的navigationController會指向他 window?.rootViewController = navaController window.makeKeyAndVisible() return true } ViewController.swift //window掛載navigationController後呈現時,才執行以下 //此時的self.navigationController與self.navigationItem才可抓到 override func viewDidLoad() { super.viewDidLoad() m_leftBtnItem = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.compose , target: self, action: #selector(ViewController.onSelectLeftAction(_:))) self.navigationItem.leftBarButtonItem = m_leftBtnItem m_rightBtnItem = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.done, target: self, action: #selector(ViewController.onSelectRightAction(_:))) self.navigationItem.rightBarButtonItem = m_rightBtnItem let titleView:UIImageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 30, height: 30)) titleView.image = UIImage(named: \"icon\") self.navigationItem.titleView = titleView } //MARK: - CallBack & Lisetner //------------------------------- func onSelectRightAction(_ sender:UIBarButtonItem){ if popRightVC == nil { popRightVC = Pop2ViewController() } else if m_isAlready { self.navigationController?.pushViewController(popRightVC!, animated: true) } } UITabBarController ＆ 切頁動畫 TabBarViewController.swift import UIKit class TabBarViewController: UITabBarController,UITabBarControllerDelegate { override func viewDidLoad() { super.viewDidLoad() let controllers:[UIViewController] = [PageOneViewController(),PageTwoViewController(),PageThreeViewController()] self.viewControllers = controllers self.delegate = self //初始全部跑一遍回到原點,起始才會出現全部選項 for i in (0 .. Bool { let fromView: UIView = tabBarController.selectedViewController!.view let toView : UIView = viewController.view if fromView == toView { return false } UIView.transition(from: fromView, to: toView, duration: 0.3, options: UIViewAnimationOptions.transitionCrossDissolve) { (finished:Bool) in } return true } } PageOneViewController.swift override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor = UIColor.red let tabBarItem:UITabBarItem = UITabBarItem(title: \"第一頁\", image: UIImage(named: \"aa\"), selectedImage: UIImage(named: \"bb\")) self.tabBarItem = tabBarItem } override func viewWillAppear(_ animated: Bool) { let tabBarItem:UITabBarItem = UITabBarItem(title: \"第一頁\", image: UIImage(named: \"aa\"), selectedImage: UIImage(named: \"bb\")) self.tabBarItem = tabBarItem } 動畫 寫在tableView willDisplayCell或是tabBarController shouldSelect viewController之中 var rotation:CATransform3D; rotation = CATransform3DMakeRotation( CGFloat(90*M_PI/180) , 0.0, 0.7, 0.4); rotation.m34 = 1.0 / (-600); //2. Define the initial state (Before the animation) toView.layer.shadowColor = UIColor.black.cgColor toView.layer.shadowOffset = CGSize(width: 10, height: 10) toView.alpha = 0; toView.layer.transform = rotation; toView.layer.anchorPoint = CGPoint(x: 0, y: 0.5) //3. Define the final state (After the animation) and commit the animation UIView.beginAnimations(\"rotation\", context: nil) UIView.setAnimationDuration(0.8) toView.layer.transform = CATransform3DIdentity; toView.alpha = 1; toView.layer.shadowOffset = CGSize(width: 0, height: 0) UIView.commitAnimations() Image 1 - Animation © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2018-07-25 13:55:33 "},"md/2-Python/1-Basic.html":{"url":"md/2-Python/1-Basic.html","title":"Basic","keywords":"","body":"Basic tagsstart Python tagsstop 型態 List Method append(x)：在list尾端增加一個成員。 count(x)：傳回在整個list裡面， x 出現了多少次。 index(x)：傳回第一個其值相等於 x 的成員之位置(index)。 remove(x)：拿掉第一個其值相等於 x. 的成員。 insert(i,x)：在某個特定的位置加入一個成員。 sort()：針對 list 裡面的成員做排序。 reverse()：反轉整個 list 裡面成員的位置。 Function max(L) min(L) len(L) cmp(L1,L2)：若值都一樣,return 0，不然return -1。 my_list = [] my_list.append(1) my_list.append(2) my_list2 = [55.55,\"Hi\",3,99,222,222] my_list2[0]=333.333 print len(my_list) print sum(my_list) print my_list2.count(222) print my_list2[0] print my_list2[-1] print my_list2[1:3] print my_list2[2:] Output 2 3 2 333.333 222 ['Hi', 3] [3, 99, 222, 222] Dictionary keys get # encoding: utf-8 passwd={'Mars':00000,'Mark':56680} passwd['Happy']=9999 passwd['Smile']=123456 del passwd['Mars'] passwd['Mark']=passwd['Mark']+1 print passwd print passwd.keys() print passwd.get('Tony') Output {'Happy': 9999, 'Smile': 123456, 'Mark': 56681} ['Happy', 'Smile', 'Mark'] None Set add # encoding: utf-8 admins = set() users = {'Smile', 'Tony','Happy','Sherry','Allen','Andy', 'Mars'} admins.add('ihc') admins.add('Mars') print admins & users print admins | users print admins ^ users print admins - users print users - admins Output set(['Mars']) set(['Allen', 'Andy', 'Smile', 'Mars', 'Tony', 'ihc', 'Happy', 'Sherry']) set(['Andy', 'Allen', 'Tony', 'Smile', 'Happy', 'ihc', 'Sherry']) set(['ihc']) set(['Sherry', 'Andy', 'Allen', 'Tony', 'Smile', 'Happy']) String len split decode repr()是将一个对象转成字符串显示，注意只是显示用，有些对象转成字符串没有直接的意思。如list,dict使用str()是无效的，但使用repr可以，这是为了看它们都有哪些值，为了显示之用。 # encoding: utf-8 s = \"Hello\" s += 'World' s1 = \"HelloWorld\".replace(\"ll\",\"1\") s2 = \"Hello\"[0]+\"i\" print s,s1,s2,len(s) Output: HelloWorld He1oWorld Hi 10 s3 = \"This is a sentence.\" s3_split=s3.split(' ') print s3_split Output: ['This', 'is', 'a', 'sentence.'] s=\"台灣\" u = s.decode('utf8') print '台',s[0],u[0] print u[0]==u'台' Output: 台 ? 台 #沒有解碼過的s是顯示不出來每一個\"中文字\"的 True data = [{'a':\"A\",'b':(2,4),'c':3.0}] print \"DATA:\",repr(data) Output DATA: [{'a':'A','c':3.0,'b':(2,4)}] Tuples List可以修改，而tuple不能修改。 Output `` Json encoding：把一个Python对象编码转换成Json字符串 json.dumps(data) decoding：把Json格式字符串解码转换成Python对象 json.loads(data_string) indent是縮排，增加可讀性 sort_keys import json data1 = {'b':789,'c':456,'a':123} d1 = json.dumps(data1,sort_keys=True,indent=4) print d1 Output { \"a\": 123, \"b\": 789, \"c\": 456 } EmployeeList = [u'1001', u'Karick', u'14-12-2020', u'1$'] to this: EmployeeList = ['1001', 'Karick', '14-12-2020', '1$'] [x.encode('UTF8') for x in EmployeeList] or [str(x) for x in EmployeeList] def convert_keys_to_string(dictionary): \"\"\"Recursively converts dictionary keys to strings.\"\"\" if not isinstance(dictionary, dict): return dictionary return dict((str(k), convert_keys_to_string(v)) for k, v in dictionary.items()) DATA = { u'spam': u'eggs', u'foo': frozenset([u'Gah!']), u'bar': { u'baz': 97 }, u'list': [u'list', (True, u'Maybe'), set([u'and', u'a', u'set', 1])]} print convert_keys_to_string(DATA) import collections def convert(data): if isinstance(data, basestring): return data.encode('UTF8') elif isinstance(data, dict): return dict(map(convert, data.iteritems())) elif isinstance(data, collections.Iterable): return type(data)(map(convert, data)) else: return data DATA = { u'spam': u'eggs', u'foo': frozenset([u'Gah!']), u'bar': { u'baz': 97 }, u'list': [u'list', (True, u'Maybe'), set([u'and', u'a', u'set', 1])]} print convert(DATA) import json s={ u'spam': u'eggs', u'foo': frozenset([u'Gah!']), u'bar': { u'baz': 97 }, u'list': [u'list', (True, u'Maybe'), set([u'and', u'a', u'set', 1])]} print str(distance_matrix_result).decode(\"unicode-escape\").encode(\"utf-8\") print json.dumps(s, encoding=\"UTF-8\", ensure_ascii=False) print os.getcwd() print os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) 編碼 coding: utf-8 coding: cp950 # encoding: utf-8 #-*- coding: utf-8 -*- #使用 utf-8 編碼 #-*- coding: cp950 -*-　 #使用 Big5 編碼（windows 下使用） total = 1 + 1 print \" 一加一等於\", total #總和 Output 一加一等於 2 Math ceil floor round pow #-*- coding: utf-8 -*- #使用 utf-8 編碼 #-*- coding: cp950 -*-　 #使用 Big5 編碼（windows 下使用 import math a = 1.1 print a, \" 無條件進位 =\", math.ceil(a) print a, \" 無條件捨去 =\", math.floor(a) print a, \" 四捨五入 =\", round(a) print \"5 的平方 = 5 ** 2 = \", 5**2 print \"5 的平方 = math.pow(5,2) = \", math.pow(5,2) print \"5 的平方根 = 5 ** (0.5) = \", 5**(0.5) print \"5 的平方根 = math.pow(5,0.5) = \", math.pow(5,0.5) Output 1.1 無條件進位 = 2.0 1.1 無條件捨去 = 1.0 1.1 四捨五入 = 1.0 5 的平方 = 5 ** 2 = 25 5 的平方 = math.pow(5,2) = 25.0 5 的平方根 = 5 ** 0.5 = 2.2360679775 5 的平方根 = math.pow(5,0.5) = 2.2360679775 迴圈 for i in range(10, 0, -1): print(i) i = 10 # 設定控制變數 while i > 0: print(i) i=i-1 Output `` 控制 & 邏輯 and or not if 3 > 5: elif 4 > 5: else: Output `` Function def my_function(x,y): return x-10,y+10 x,y = my_function(10,20) print x,y Output 0 30 類別Class __init__ class Student: def __init__(self, name, grade, age=26): self.name = name self.grade = grade self.age = age def set_name(self, name): self.name = name student_objects=[] student_objects.append( Student('john', 'B', 15) ) student_objects.append( Student('dave', 'A', 12) ) student_objects.append( Student('jane', 'A', 10) ) student_objects[0].set_name('John') for i in student_objects: print i.name,i.grade,i.age Output John B 15 dave A 12 jane A 10 導入外部資源import import sys \"\"\"插入sys檔案中所有函式，使用sys檔中的write函式前須加檔名\"\"\" from time import time \"\"\"從time檔案插入time()函式，使用time()前不需要加檔名\"\"\" sys.stdout.write( str(time()) + \"\\n\" ) Output 1409796132.99 #當下的time File # encoding: utf-8 import sys file_in = file('db.txt','r') file_out = file('copy.txt','w') for line in file_in: for i in range(0,len(line)): if line[i]!=\"\\n\": sys.stdout.write(line[i]+',') else: sys.stdout.write(line[i]) file_out.write(line[i]) sys.stdout.write(\"\\n\") file_in.close() file_out.close() \"\"\" # db.txt 1111 2222 ssss wwww 5555 \"\"\" Output 1,1,1,1, 2,2,2,2, s,s,s,s, w,w,w,w, 5,5,5,5, 排序 lambda是簡易型函式，只能回傳一個值 attrgetter如果需要兩個值以上的排列順序，會用attrgetter # encoding: utf-8 class Student: def __init__(self, name, grade, age): self.name = name self.grade = grade self.age = age def set_name(self, name): self.name = name student_objects=[] student_objects.append( Student('john', 'B', 15) ) student_objects.append( Student('dave', 'A', 12) ) student_objects.append( Student('jane', 'A', 10) ) student_objects.sort(key=lambda i: i.grade) for i in student_objects: print i.name,i.grade,i.age print from operator import attrgetter student_objects.sort(key=attrgetter('grade', 'age'),reverse=True) for i in student_objects: print i.name,i.grade,i.age print Output dave A 12 jane A 10 john B 15 john B 15 dave A 12 jane A 10 \"\"\" str = \"Nearest Pension Am Park is at Sophie-Charlotten 57, Berlin\" print (any(char.isdigit() for char in str)) print [int(s) for s in \"Nearest Pension Am Park is at Sophie-Charlotten 57, Berlin\".split() if s.isdigit()] \"\"\" import re import number text = \"Nearest aas 23 12 Pension Am Park is at Sophie-Charlotten 57, Berlin\" p = re.compile('(\\d+)') group = p.split(text) d = \"\" for i in group: if i.isdigit() : i = number.tranNumToEng(i) d = d + i print d \"\"\" print p.findall(text) print p.split(text) match = p.search(text) if match: print match.group() match = p.match(text) if match: print match.group() iterator = p.finditer(text) for match in iterator: print match.span() \"\"\" #([0-9]+) = (\\d+) != \\d+ 这里介绍一下python执行shell命令的四种方法： 1、os模块中的os.system()这个函数来执行shell命令 1 2 3 os.system('ls') anaconda-ks.cfg install.log install.log.syslog send_sms_service.py sms.py 0 注，这个方法得不到shell命令的输出。 2、popen()#这个方法能得到命令执行后的结果是一个字符串，要自行处理才能得到想要的信息。 1 2 3 4 5 import os str = os.popen(\"ls\").read() a = str.split(\"\\n\") for b in a: print b 这样得到的结果与第一个方法是一样的。 3、commands模块#可以很方便的取得命令的输出（包括标准和错误输出）和执行状态位 1 2 3 4 5 6 7 8 9 10 11 12 import commands a,b = commands.getstatusoutput('ls') a是退出状态 b是输出的结果。 import commands a,b = commands.getstatusoutput('ls') print a 0 print b anaconda-ks.cfg install.log install.log.syslog commands.getstatusoutput(cmd)返回（status,output) commands.getoutput(cmd)只返回输出结果 commands.getstatus(file)返回ls -ld file 的执行结果字符串，调用了getoutput，不建议使用这个方法。 4、subprocess模块 使用subprocess模块可以创建新的进程，可以与新建进程的输入/输出/错误管道连通，并可以获得新建进程执行的返回状态。使用subprocess模块的目的是替代os.system()、os.popen()、commands.等旧的函数或模块。 import subprocess 1、subprocess.call(command, shell=True) 会直接打印出结果。 2、subprocess.Popen(command, shell=True) 也可以是subprocess.Popen(command, stdout=subprocess.PIPE, shell=True) 这样就可以输出结果了。 如果command不是一个可执行文件，shell=True是不可省略的。 shell=True意思是shell下执行command 这四种方法都可以执行shell命令。 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2018-07-25 13:55:33 "},"md/3-CPP/1-Basic.html":{"url":"md/3-CPP/1-Basic.html","title":"Basic","keywords":"","body":"Basic tagsstart C++ tagsstop 基本介紹 %.*s 指定只要搜尋「檔案」名稱 find /var/log -iname '*.log' -type f iothubtransportamqp_unittests /usr/bin/ccCMakeFiles/simplesample_amqp.dir/simplesample_amqp.c.o CMakeFiles/simplesample_amqp.dir/linux/main.c.o -o simplesample_amqp-L/home/zhenkun/azure-iot-sdks/c/serializer/samples/simplesample_amqp/simplesample_amqp_dll -rdynamic ../../libserializer.a ../../../iothub_client/libiothub_client.a ../../../iothub_client/libiothub_client_amqp_transport.a ../../../azure-c-shared-utility/c/libaziotsharedutil.a -lqpid-proton -lcurl -lpthread -Wl,-rpath,/home/zhenkun/azure-iot-sdks/c/serializer/samples/simplesample_amqp/simplesample_amqp_dll // ConsoleApplication1.cpp : 定義主控台應用程式的進入點。 // #include \"stdafx.h\" #include #include using namespace std; class A { public: A(int a, int b, int c[3]) :ma(a), mb(b), mc{ c[0],c[1],c[2] } { cout // ConsoleApplication1.cpp : 定義主控台應用程式的進入點。 // #include \"stdafx.h\" #include #include using namespace std; class A { public: A(int a, int b, int c[3]) :ma(a), mb(b), mc(c) { cout U32ToString - StringUtil.h IOTHUB_CLIENT_RESULT res = IOTHUB_CLIENT_OK; res = REGISTER_DISPATCHERS(OID_DEVICE, object_device); // And an easy macro to wrap vtable registration #define REGISTER_DISPATCHERS(id, x) \\ register_dm_dispatchers(id, \\ &ALLOWED_OP_LIST(x)[0], \\ &x ## _instance_list, \\ READ_DISPATCHER_NAME(x), \\ EXEC_DISPATCHER_NAME(x), \\ WRITE_DISPATCHER_NAME(x), \\ SIGNAL_RESOURCE_CHANGE_NAME(x)) // default function names for our dispatcher objects #define INSTANCE_GETTER_NAME(x) get_ ## x ## _instance #define READ_DISPATCHER_NAME(x) dispatch_ ## x ## _read #define EXEC_DISPATCHER_NAME(x) dispatch_ ## x ## _exec #define WRITE_DISPATCHER_NAME(x) dispatch_ ## x ## _write #define SIGNAL_RESOURCE_CHANGE_NAME(x) signal_ ## x ## _resource_changed = register_dm_dispatchers(3, \\ &allowedobject_deviceoperations[0], \\ &object_device_instance_list, \\ dispatch_object_device_read, \\ dispatch_object_device_exec, \\ dispatch_object_device_write, \\ signal_object_device_resource_changed) // funtion prototypes for the vtable typedef IOTHUB_CLIENT_RESULT(*FUNC_DISPATCH_READ_TO_OBJ_INSTANCE)(void *obj, uint16_t propertyId, lwm2m_data_t *tlvP); typedef IOTHUB_CLIENT_RESULT(*FUNC_DISPATCH_EXEC_TO_OBJ_INSTANCE)(void *obj, uint16_t propertyId); typedef IOTHUB_CLIENT_RESULT(*FUNC_DISPATCH_WRITE_TO_OBJ_INSTANCE)(void *obj, uint16_t propertyId, lwm2m_data_t *tlvP); typedef void(*FUNC_SIGNAL_RESOURCE_CHANGE)(void *obj); // A way to register that vtable IOTHUB_CLIENT_RESULT register_dm_dispatchers( uint16_t objectId, const DmOps *allowedOperations, LIST_HANDLE *instanceList, FUNC_DISPATCH_READ_TO_OBJ_INSTANCE readDispatcher, FUNC_DISPATCH_EXEC_TO_OBJ_INSTANCE execDispatcher, FUNC_DISPATCH_WRITE_TO_OBJ_INSTANCE writeDispatcher, FUNC_SIGNAL_RESOURCE_CHANGE changeSignaller); Q:gcc的全稱是什麼： A: gcc 是 gnu compiler collection（gnu 編譯器套裝），它不僅僅只是編譯c語言的編譯器，它提供了對c、面向物件的c(object c), C++, java, Ada 語言的編譯服務。過去有一段時間，它被成為gnu C compiler是因為它最初的開發目的的確是只提供了c編譯功能，但是現在已經不在是這樣了。 Q:gcc 和g++什麼關係 A:事實上只有一個C++編譯器，那就是g++。g++不僅僅是一個C++預處理器，而是一個實實在在的C++編譯器。由於它的名字 GNU C++ Compiler 也能縮寫成GCC，所以有時候有人叫它gcc也並不錯。而我們通常所說的gcc是一個編譯器套裝，gcc命令只是一個調用各個實際編譯器的快捷方式而已。 Q:gcc所支援的C語言規範有哪些 A: 目前主要的C語言規範有c89(c90)， c95(94)和c99。C89是最早的C語言規範，於89年提出，90年先由美國國家標準局推出ANSI版本，後來被接納為ISO國際標準 (ISO/IEC 9899:1990),因而有時也稱為c90。但在94和96年分別對c90進行了兩次錯誤修正，gcc支援的是修正後的c89(90)版本的C語言規範。在95年提出過對90版規範的修訂案，稱為 C95或者AMD1。gcc也支援c95規範。最新的一次C規範修訂在99年制定（ISO/IEC 9899:1999），即常稱的C99規範。在2001年對C99的錯誤進行了修正，gcc支持的修正後的c99規範，但是到目前為止，gcc還沒有完成對c99規範的完全支援。 在默認設置下，gcc對c語言進行了一些自己的擴展。在不加語言設置參數的情況下，gcc使用c89規範和自己的一些擴展。在將來如果gcc完成了對c99的全面支持，可能默認會使用c99規範加gcc自己的擴展。 gcc下的語言規範設置： -std=iso9899:1990，-ansi或-std=c89 （三者完全等同）來指定完全按照c89規範，而禁止gcc對c語言的擴展。 -std=iso9899:199409 使用C95規範 -std=c99 或者 -std=iso9899:1999 使用C99規範。 -std=gnu89 使用c89規範加上gcc自己的擴展（目前默認） -std=gnu99 使用c99規範加上gcc自己的擴展 deque vector future include 順序 // copy_if example #include // std::cout #include // std::copy_if, std::distance #include // std::vector int main () { std::vector foo = {25,15,5,-5,-15}; std::vector bar (foo.size()); // copy only positive numbers: auto it = std::copy_if (foo.begin(), foo.end(), bar.begin(), [](int i){return !(i class ManagedObj { private: T* object; public: T& operator*() { return *object; } } How to typedef a function pointer with template arguments In C++11, you can use this: template using ExecFunc = void(*)(X); defines ExecFunc. In C++03, you have to use this instead: template struct ExecFunc { typedef void(*type)(X); }; and use typename ExecFunc::type within Executor. structs in C with initial values you can not do it in this way Use the following instead typedef struct { int id; char* name; }employee; employee emp = { .id = 0 .name = \"none\" }; You can use macro to define and initialize your instances. this will make easiier to you each time you want to define new instance and initialize it. typedef struct { int id; char* name; }employee; #define INIT_EMPLOYEE(X) employee X = {.id = 0, .name =\"none\"} and in your code when you need to define new instance with employee type, you just call this macro like: INIT_EMPLOYEE(emp); C++ dictionary API Use std::map then you can do: #include map[\"apple\"] = \"A tasty fruit\"; map[\"word\"] = \"A group of characters that makes sense\"; and then map::iterator it; cout \" second \" second “Undefined reference to” template class constructor [duplicate] This is a common question in C++ programming. There are two valid answers to this. There are advantages and disadvantages to both answers and your choice will depend on context. The common answer is to put all the implementation in the header file, but there's another approach will will be suitable in some cases. The choice is yours. The code in a template is merely a 'pattern' known to the compiler. The compiler won't compile the constructors cola::cola(...) and cola::cola(...) until it is forced to do so. And we must ensure that this compilation happens for the constructors at least once in the entire compilation process, or we will get the 'undefined reference' error. (This applies to the other methods of cola also.) Understanding the problem The problem is caused by the fact that main.cpp and cola.cpp will be compiled separately first. In main.cpp, the compiler will implicitly instantiate the template classes cola and cola because those particular instantiations are used in main.cpp. The bad news is that the implementations of those member functions are not in main.cpp, nor in any header file included in main.cpp, and therefore the compiler can't include complete versions of those functions in main.o. When compiling cola.cpp, the compiler won't compile those instantiations either, because there are no implicit or explicit instantiations of cola or cola. Remember, when compiling cola.cpp, the compiler has no clue which instantiations will be needed; and we can't expect it to compile for every type in order to ensure this problem never happens! (cola, cola, cola, cola > ... and so on ...) The two answers are: Tell the compiler, at the end of cola.cpp, which particular template classes will be required, forcing it to compile cola and cola. Put the implementation of the member functions in a header file that will be included every time any other 'translation unit' (such as main.cpp) uses the template class. Answer 1: Explicitly instantiate the template, and its member definitions At the end of cola.cpp, you should add lines explicitly instantiating all the relevant templates, such as template class cola; template class cola; and you add the following two lines at the end of nodo_colaypila.cpp: template class nodo_colaypila; template class nodo_colaypila; This will ensure that, when the compiler is compiling cola.cpp that it will explicitly compile all the code for the cola and cola classes. Similarly, nodo_colaypila.cpp contains the implementations of the nodo_colaypila classes. In this approach, you should ensure that all the of the implementation is placed into one .cpp file (i.e. one translation unit) and that the explicit instantation is placed after the definition of all the functions (i.e. at the end of the file). Answer 2: Copy the code into the relevant header file The common answer is to move all the code from the implementation files cola.cpp and nodo_colaypila.cpp into cola.h and nodo_colaypila.h. In the long run, this is more flexible as it means you can use extra instantiations (e.g. cola) without any more work. But it could mean the same functions are compiled many times, once in each translation unit. This is not a big problem, as the linker will correctly ignore the duplicate implementations. But it might slow down the compilation a little. Summary The default answer, used by the STL for example and in most of the code that any of us will write, is to put all the implementations in the header files. But in a more private project, you will have more knowledge and control of which particular template classes will be instantiated. In fact, this 'bug' might be seen as a feature, as it stops users of your code from accidentally using instantiations you have not tested for or planned for (\"I know this works for cola and cola, if you want to use something else, tell me first and will can verify it works before enabling it.\"). Finally, there are three other minor typos in the code in your question: You are missing an #endif at the end of nodo_colaypila.h in cola.h nodo_colaypila* ult, pri; should be nodo_colaypila *ult, *pri; - both are pointers. nodo_colaypila.cpp: The default parameter should be in the header file nodo_colaypila.h, not in this implementation file. Passing member function pointer to member object in c++ Taking everyone's suggestions together, your final solution will look like: #include using std::cout; usind std::endl; class foo; // tell the compiler there's a foo out there. class bar { public: // If you want to store a pointer to each type of function you'll // need two different pointers here: void (*freeFunctionPointer)(); void (foo::*memberFunctionPointer)(); }; class foo { public: bar myBar; void hello(){ cout using std::cout; using std::endl; class foo; typedef void (*FreeFn)(); typedef void (foo::*MemberFn)(); class bar { public: bar() : freeFn(NULL), memberFn(NULL) {} void operator()(foo* other) { if (freeFn != NULL) { freeFn(); } else if (memberFn != NULL) { ((other)->*(memberFn))(); } else { cout std::random_shuffle produces same result each time [duplicate] C++ random numbers aren't truly random - they are generated from initial value called seed. If you don't set the seed, it will always be the same, so generated sequence won't change. std::random_shuffle depends on random number generation, so it will behave this way as well. So how to set the seed? Use: srand(time(0)); before any calls to functions using random numbers. It will set the seed to current time in seconds. Don't forget to add appropritate header files. Pass iterator as a function parameter The particular error you get is because you'd need a template template argument: template class C, typename T> // ^^^^^^^^^^^^^^^^^^^^^^^^^^^ T sum( C::iterator begin, C::iterator end ) However, the standard containers typically have more than just one template argument: template > class vector and it is a bit non-trivial to write such function correctly. You could use variadic template arguments, or you could do like the standard library does, and only specialize as much as you really need: // namespace std { template void sort (RandomAccessIterator first, RandomAccessIterator last); } In your case (pretending that your need is not covered by the standard algorithms library already): template auto sum(Iterator begin, Iterator end) -> decltype(*begin+*begin) // the type of summing two of them { if (begin == end) throw std::logic_error(\"....\"); auto s = *begin; ++begin; for (; begin != end; ++begin) { s += *begin; } return s; } There are some more differences from your original code: the new code does not assume a null or a default constructor defined (T s = null;) does not introduce additional iterator (it) uses pre-increment throws an exception when begin==end If you add an init parameter, you can make it almost noexcept: template T sum(Iterator begin, Iterator end, T init) { for (; begin!=end; ++begin) init += *begin; return init; } But only almost, because init += *begin could still throw. If you have such signature, you've by the way reproduced the signature of std::accumulate. bool x = true; printf(\"%d\\n\", x); // prints 1 But why not printf(x ? \"true\" : \"false\"); or better printf(\"%s\", x ? \"true\" : \"false\"); or even better fputs(x ? \"true\" : \"false\", stdout); 不完整的类声明(incomplete class declarations ) 问题 和 解答 两个类放入一个文件时, 如果包含内联函数, 及友元(friend)类, 则函数放置的顺序尤为重要, 类的前置声明(class forward declaration)也需要注意. 否则会产生编译错误: 不完整的类声明(incomplete class declarations) 错误: \"error: return type 'class StrBlobPtr' is incomplete\" 错误: \"error: invalid use of incomplete type 'class StrBlobPtr'\" 则需要修改类的成员函数的放置位置, 一般来说, 正确的写法为: [cpp] view plain copy print? class B; class A { friend class B; ...... }; class B { ...... }; ... A::fcn { ...... } ... B::fcn { ...... } 即 声明在前, 实现在后, 如果是内联(inline)函数使用B类, 则有可能找不到B类的成员; Why is conversion from string constant to 'char*' valid in C but invalid in C++ The C++11 Standard (ISO/IEC 14882:2011) says in § C.1.1: char* p = \"abc\"; // valid in C, invalid in C++ For the C++ it's OK as a pointer to a String Literal is harmful since any attempt to modify it leads to a crash. But why is it valid in C? The C++11 says also: char* p = (char*)\"abc\"; // OK: cast added Up through C++03, your first example was valid, but used a deprecated implicit conversion--a string literal should be treated as being of type char const *, since you can't modify its contents (without causing undefined behavior). As of C++11, the implicit conversion that had been deprecated was officially removed, so code that depends on it (like your first example) should no longer compile. You've noted one way to allow the code to compile: although the implicit conversion has been removed, an explicit conversion still works, so you can add a cast. I would not, however, consider this \"fixing\" the code. Truly fixing the code requires changing the type of the pointer to the correct type: char const *p = \"abc\"; // valid and safe in either C or C++. cannot pass objects of non-trivially-copyable type ‘const class mysqlpp::String’ through ‘...’ It looks like you are trying to pass a mysqlpp::String object to gtk_list_store_set(). You can't do this, because it is a C function and does not understand C++ objects.1 Instead, call c_str() on the string object, which returns a pointer to a null-terminated string. gtk_list_store_set() will copy the value of the pointed-to string into its own internal structures, so there will be no data ownership issues. gtk_list_store_set(GTK_LIST_STORE(list_store), &list_iterator, 0, resp[i][1].c_str(), 1, resp[i][2].c_str(), 2, resp[i][1].c_str(), -1); 1 Specifically, you are trying to pass a C++ object in a va_arg structure, which is what ... represents in the C function prototype. You can only do this with so-called trivially-copyable objects, and mysqlpp::String objects are not trivially-copyable. static in c 其次，在讀有關Linux的核心程式碼的時候，看到許多宣告成 static 的函數，為什麼要宣告成 static 的函數呢？這樣的宣告和一般沒有宣告成 static 的函數有什麼不同？ 這個static 的意義是代表此函數不能夠在runtime 時被作業系統在記憶體中swap out，因此核心程式碼大部分都是static static 在c 當中的用法有下列幾種： 1. function 內的變數使用static 宣告 如： void MyFun() { static int i=0; } i 為static，i 的生命週期會到程式結束，但是他的scope 還是在MyFun 中，每次呼叫MyFun . i 的值會keep 上次呼叫最後一次設定的值。 實作範例： #include #include void MyFun() {static int i=1; printf(\"static i :%d\\n\",i++); } void MyFun2() {int i=1; printf(\"Non statice i :%d\\n\",i++); } main() { int i; for(i=0;i pragma once與#ifndef #define #endif的區別 一、相同點 兩者的共同點都是为了避免同一個文件被 include 多次，但是 #ifndef #define #endif 不只有這個作用。 在能夠支持這兩種方式的編譯器上，二者並沒有太大的區別，但是兩者仍然還是有一些細微的區別。 二、收集理解 1.#pragma once 這個是編譯器相關，就是說在這個編譯系統上能用，在其他編譯系統不一定行，即移植性差。不過現在基本上已經是每個編譯器都有這個定義了。 此方式由編譯器保證同一個文件不會被包含多次。注意：這裏所說的“同一個文件”是指物理上的一個文件，而不是指內容相同的兩個文件。於是不必再費勁想個宏名了，當然也就可以避免宏的名字沖突問題了。 缺點：如果某個頭文件有多份拷貝，本方法不能保證他們不被重复包含。 舉例：在一般的 MFC 程序中可以看到 #if !defined(AFX_STDAFX_H__32722022_E372_4A5C_8EC5_BBB243CEDE1D__INCLUDED_) #define AFX_STDAFX_H__32722022_E372_4A5C_8EC5_BBB243CEDE1D__INCLUDED_ #if _MSC_VER > 1000 #pragma once #endif // _MSC_VER > 1000 // TODO: reference additional headers your program requires here //{{AFX_INSERT_LOCATION}} // Microsoft Visual C++ will insert additional declarations immediately before the previous line. #endif // !defined(AFX_STDAFX_H__32722022_E372_4A5C_8EC5_BBB243CEDE1D__INCLUDED_) 其中 _MSC_VER 分解如下： MS：Microsoft（微軟）的簡寫 C：MSC 就是 Microsoft 出的 C 編譯器 VER：Version（版本）的簡寫 #if _MSC_VER > 1000 的意思就是如果編譯器版本高於 1000（VC++5.0） 可以看到：在 _MSC_VER 小於 1000 時，它對 #pragma once 是不支持的。 2.#ifndef #define #endif 該方法與 C++ 語言相關，是 C++ 語言中的宏定義，通過宏定義避免文件多次編譯。所以在所有支持 C++ 語言的編譯器上都是有效的。如果寫的程序要跨平台，最好使用這種方式。該方式由於是 C++ 語言本身支持，所以移植性好。它依賴於宏名字不能沖突，這不光可以保證同一個文件不會被包含多次，也能保證內容完全相同的兩個文件不會被不小心同時包含。另外，为了保證不同頭文件中的宏名不沖突，故采取類似於_ABC_H_的取名方式。其中，abc.h为當前頭文件名。 舉例：常常在一些頭中可以看到 #ifndef __SOMEFILE_H__ #define __SOMEFILE_H__ // 一些聲明語句 #endif 缺點：如果不同頭文件的宏名不小心“撞車”，可能就會導致頭文件明明存在，編譯器卻硬說找不到聲明的狀況。但這個缺點恰恰是我們可以利用的優點，#ifndef 方式可以通過前面介紹的特殊的宏的取名方式來避免名稱沖突問題，於是其缺點也就不复存在了，進而 #ifndef 方式就更常用了。 三、相比之下 1.性能上的區別 使用 #ifndef 的話，編譯器每次看到 #include 這個文件都需要讀入文件，解析代碼； 而使用 #pragma once 編譯器根本不會重复打開文件， 大大提高了效率。 2.編碼風格上的區別 使用 #pragma once 的代碼簡潔，顯然比 #ifndef 要簡短許多，重要的是它避免了頭文件標號（如 __myheader_h__ ）的重定義或者 #endif 包含範圍錯誤的情況。 3.語意上的區別 #pragma once 是針對文件的，它告訴編譯器，本文件只編譯一次。 #ifndef #define #endif 只是針對文件中的某一個標號而言的，它能用於防止三個指令間所包含內容的重复性處理。就這一點而言，後者更靈活。 4.可移植性方面 #pragma once 是微軟的開發工具中所使用的，如 .net，vc6 等工具可以完好的支持； #ifndef #define #endif 是標准裏面的一部分，所以對於任何完好支持 C/C++ 的編譯器都能使用。顯而易見，後者的可移植性更高。 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2018-07-25 13:55:33 "},"md/3-CPP/2-future.html":{"url":"md/3-CPP/2-future.html","title":"Future","keywords":"","body":"future tagsstart std11 tagsstop © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2018-07-25 13:55:33 "},"md/4-IDE/1-Xcode.html":{"url":"md/4-IDE/1-Xcode.html","title":"Xcode","keywords":"","body":"Xcode tagsstart IDE Xcode Mac Software tagsstop 快捷鍵 CTRL+I：格式化程式碼 command + /：註解單行 © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2018-07-25 13:55:33 "},"md/4-IDE/2-Eclipse.html":{"url":"md/4-IDE/2-Eclipse.html","title":"Eclipse","keywords":"","body":"Eclipse tagsstart IDE Eclipse Software tagsstop 快捷鍵 ctrl+o：快速outline F3: 打开申明（Open declaration） Ctrl+Shift+F 格式化当前代码 Ctrl + Shift + O: 引入imports语句 ALT+/ 提示 Alt+←】、【Alt+→】 后退历史记录和前进历 Ctrl+M窗口最大化和还原 Ctrl + D : 删除本行 Ctrl + / : 注释本行 cmake -G\"Eclipse CDT4 - Unix Makefiles\" -D CMAKE_BUILD_TYPE=Debug -D CMAKE_ECLIPSE_VERSION=4.6 . Initializer Format(line wrapping) constructor initializer list in Eclipse CDT Click on: Window -> Preferences Go to: C/C++ -> Code Style -> Formatter Here, as first thing you have to create a new profile. Select tab: Line Wrapping Go to: Function declarations -> Constructor initializer list On the bottom, you have to set: Line wrapping policy: Wrap all elements, every element on a new line. check \"Force split, even if line is shorter than maximum\" Indentation policy: indent on column © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2018-07-25 13:55:33 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags © 2017 Trashman all right reserved，powered by Gitbook修訂時間： 2018-07-25 13:55:33 Swift Basic I OS Language Basic I OS iOS I OS Framework I OS Python Basic C++ Basic std11 Future IDE Xcode Eclipse Xcode Xcode Mac Xcode Software Xcode Eclipse Eclipse Eclipse "}}